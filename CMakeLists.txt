CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
IF(COMMAND CMAKE_POLICY)
  CMAKE_POLICY(SET CMP0003 NEW)
ENDIF(COMMAND CMAKE_POLICY)
PROJECT(VTK)

# the following lines are for cross compiling support
# we may get here also from ParaView, in this case don't change the filename
IF(NOT EXPORT_EXECUTABLES_FILE)
  # the generators which are needed during the build have to be imported
  # from a native build, which exports them, requires cmake cvs or 2.6
  IF(CMAKE_CROSSCOMPILING)
    FIND_PACKAGE(VTKCompileTools REQUIRED)
  ENDIF(CMAKE_CROSSCOMPILING)

  SET(EXPORT_EXECUTABLES_FILE "${CMAKE_BINARY_DIR}/VTKCompileToolsConfig.cmake")
  SET(EXPORT_EXECUTABLES_NAMESPACE "")
  FILE(WRITE "${EXPORT_EXECUTABLES_FILE}" "#generated by VTK, do not edit\n")
ENDIF(NOT EXPORT_EXECUTABLES_FILE)

# EXPORT() will be in cmake 2.6, add an empty macro so cmake 2.4 is still able to build VTK
IF(NOT COMMAND EXPORT)
  MACRO(EXPORT)
  ENDMACRO(EXPORT)
ENDIF(NOT COMMAND EXPORT)

# GET_PROPERTY() will be in cmake 2.6
IF(COMMAND GET_PROPERTY)
  GET_PROPERTY(VTK_TARGET_SUPPORTS_SHARED_LIBS
    GLOBAL PROPERTY TARGET_SUPPORTS_SHARED_LIBS)
ELSE(COMMAND GET_PROPERTY)
  SET(VTK_TARGET_SUPPORTS_SHARED_LIBS  TRUE)
ENDIF(COMMAND GET_PROPERTY)


# Warn when using "old style" CMake install commands... But only when
# building VTK itself.
#
IF("${VTK_BINARY_DIR}" STREQUAL "${CMAKE_BINARY_DIR}")
  MACRO(INSTALL_TARGETS)
    MESSAGE(FATAL_ERROR "Somebody is calling old INSTALL_TARGETS command with arguments: ${ARGV}")
  ENDMACRO(INSTALL_TARGETS)
  MACRO(INSTALL_PROGRAMS)
    MESSAGE(FATAL_ERROR "Somebody is calling old INSTALL_PROGRAMS command with arguments: ${ARGV}")
  ENDMACRO(INSTALL_PROGRAMS)
  MACRO(INSTALL_FILES)
    MESSAGE(FATAL_ERROR "Somebody is calling old INSTALL_FILES command with arguments: ${ARGV}")
  ENDMACRO(INSTALL_FILES)
ENDIF("${VTK_BINARY_DIR}" STREQUAL "${CMAKE_BINARY_DIR}")

SET(VTK_CMAKE_DIR "${VTK_SOURCE_DIR}/CMake")
SET(CMAKE_MODULE_PATH "${VTK_CMAKE_DIR}" ${CMAKE_MODULE_PATH})

#-----------------------------------------------------------------------------
# VTK version number.  An even minor number corresponds to releases.
SET(VTK_MAJOR_VERSION 5)
SET(VTK_MINOR_VERSION 2)
SET(VTK_BUILD_VERSION 1)
SET(VTK_VERSION
    "${VTK_MAJOR_VERSION}.${VTK_MINOR_VERSION}.${VTK_BUILD_VERSION}")

# Append the library version information to the library target
# properties.  A parent project may set its own properties and/or may
# block this.
IF(NOT VTK_NO_LIBRARY_VERSION)
  SET(VTK_LIBRARY_PROPERTIES ${VTK_LIBRARY_PROPERTIES}
    VERSION "${VTK_VERSION}"
    SOVERSION "${VTK_MAJOR_VERSION}.${VTK_MINOR_VERSION}"
    )
ENDIF(NOT VTK_NO_LIBRARY_VERSION)

#-----------------------------------------------------------------------------
# Determine whether we are being built by CTest and if so the version.
# For CTest 2.2 and higher this will contain the version number.  For
# earlier CTest versions this will contain just "1".  If not
# configuring from CTest this should be empty, so set the result to a
# literal "0" (helps with numerical comparisons).
SET(VTK_TEST_FROM_CTEST "$ENV{DASHBOARD_TEST_FROM_CTEST}")
IF(NOT VTK_TEST_FROM_CTEST)
  SET(VTK_TEST_FROM_CTEST 0)
ENDIF(NOT VTK_TEST_FROM_CTEST)

# Determine whether tests requiring the configuration type to be known
# can be run.  Start by assuming the configuration type is known.
# This is the case when using a generator supporting only one
# configuration type.
SET(VTK_TEST_CONFIG_TYPE_KNOWN 1)
IF(CMAKE_CONFIGURATION_TYPES)
  # When there are multiple configuration types we must be running
  # tests with a CTest that knows how to give the configuration type
  # to the test when it runs.  This requires CTest 2.2 or higher.
  IF(VTK_TEST_FROM_CTEST LESS "2.2")
    # This is either a CTest older than 2.2 or not a CTest.
    # The configuration type will not be known when running the tests.
    SET(VTK_TEST_CONFIG_TYPE_KNOWN 0)
  ENDIF(VTK_TEST_FROM_CTEST LESS "2.2")
ENDIF(CMAKE_CONFIGURATION_TYPES)

#-----------------------------------------------------------------------------
# Load some macros.
INCLUDE(${VTK_CMAKE_DIR}/vtkDependentOption.cmake)
INCLUDE(${VTK_CMAKE_DIR}/vtkThirdParty.cmake)
INCLUDE(${VTK_CMAKE_DIR}/vtkExportKit.cmake)
INCLUDE(${VTK_CMAKE_DIR}/vtkMakeInstantiator.cmake)
INCLUDE(${CMAKE_ROOT}/Modules/CMakeExportBuildSettings.cmake)

#-----------------------------------------------------------------------------
# Choose static or shared libraries.
INCLUDE(${VTK_CMAKE_DIR}/vtkSelectSharedLibraries.cmake)

#-----------------------------------------------------------------------------
# Does VTK require support for 64 bit file systems
INCLUDE(${VTK_CMAKE_DIR}/CheckCXXSourceRuns.cmake)
FILE(READ "${VTK_CMAKE_DIR}/vtkRequireLargeFilesSupport.cxx"
  VTK_REQUIRE_LARGE_FILE_SUPPORT_FILE)
CHECK_CXX_SOURCE_RUNS("${VTK_REQUIRE_LARGE_FILE_SUPPORT_FILE}"
  CMAKE_REQUIRE_LARGE_FILE_SUPPORT "Support for 64 bit file systems")
SET(VTK_REQUIRE_LARGE_FILE_SUPPORT ${CMAKE_REQUIRE_LARGE_FILE_SUPPORT})

#-----------------------------------------------------------------------------
# Discover the name of the runtime library path environment variable
# and put the result in SHARED_LIBRARY_PATH_VAR_NAME.
# The result depends on the platform and on some platforms it depends on
# the compiler options (32-bit vs. 64-bit).

INCLUDE(${VTK_CMAKE_DIR}/SharedLibraryPathVarName.cmake)

#-----------------------------------------------------------------------------
# Output directories.
IF(NOT LIBRARY_OUTPUT_PATH)
  SET(LIBRARY_OUTPUT_PATH ${VTK_BINARY_DIR}/bin CACHE INTERNAL "Single output directory for building all libraries.")
ENDIF(NOT LIBRARY_OUTPUT_PATH)
IF(NOT EXECUTABLE_OUTPUT_PATH)
  SET(EXECUTABLE_OUTPUT_PATH ${VTK_BINARY_DIR}/bin CACHE INTERNAL "Single output directory for building all executables.")
ENDIF(NOT EXECUTABLE_OUTPUT_PATH)
SET(VTK_LIBRARY_DIR ${LIBRARY_OUTPUT_PATH}/${CMAKE_CFG_INTDIR})
SET(VTK_EXECUTABLE_DIR ${EXECUTABLE_OUTPUT_PATH}/${CMAKE_CFG_INTDIR})
SET(CXX_TEST_PATH ${EXECUTABLE_OUTPUT_PATH})

#-----------------------------------------------------------------------------
# Configure install locations.  This allows parent projects to modify
# the install location.  Optionally allow the project to specify a
# single VTK_INSTALL_ROOT which basically adds to its install prefix
# for VTK only.

# The location in which to install VTK executables.
IF(NOT VTK_INSTALL_BIN_DIR)
  SET(VTK_INSTALL_BIN_DIR ${VTK_INSTALL_ROOT}/bin)
ENDIF(NOT VTK_INSTALL_BIN_DIR)

# The location in which to install VTK header files.
IF(NOT VTK_INSTALL_INCLUDE_DIR)
  SET(VTK_INSTALL_INCLUDE_DIR
    ${VTK_INSTALL_ROOT}/include/vtk-${VTK_MAJOR_VERSION}.${VTK_MINOR_VERSION}
    )
ENDIF(NOT VTK_INSTALL_INCLUDE_DIR)

# The location in which to install VTK libraries.
IF(NOT VTK_INSTALL_LIB_DIR)
  SET(VTK_INSTALL_LIB_DIR 
    ${VTK_INSTALL_ROOT}/lib/vtk-${VTK_MAJOR_VERSION}.${VTK_MINOR_VERSION}
    )
ENDIF(NOT VTK_INSTALL_LIB_DIR)

# The location in which to install CMake scripts for packaging VTK.
IF(NOT VTK_INSTALL_PACKAGE_DIR)
  SET(VTK_INSTALL_PACKAGE_DIR ${VTK_INSTALL_LIB_DIR})
ENDIF(NOT VTK_INSTALL_PACKAGE_DIR)

# The location in which to install VTK doxygen documentation helper
# files.
IF(NOT VTK_INSTALL_DOXYGEN_DIR)
  SET(VTK_INSTALL_DOXYGEN_DIR ${VTK_INSTALL_PACKAGE_DIR}/doxygen)
ENDIF(NOT VTK_INSTALL_DOXYGEN_DIR)

# The location in which to install VTK documentation files that
# are not automatically generated.
IF(NOT VTK_INSTALL_DOC_DIR)
  SET(VTK_INSTALL_DOC_DIR ${VTK_INSTALL_PACKAGE_DIR}/doc)
ENDIF(NOT VTK_INSTALL_DOC_DIR)

# Compute the proper location for installing the Tcl package.  This
# must be a fixed relative path below the library install location and
# is therefore not settable by parent projects.
SET(VTK_INSTALL_TCL_DIR ${VTK_INSTALL_LIB_DIR})

IF(NOT VTK_INSTALL_JAVA_DIR)
  SET(VTK_INSTALL_JAVA_DIR ${VTK_INSTALL_PACKAGE_DIR}/java)
ENDIF(NOT VTK_INSTALL_JAVA_DIR)

# There are three basic components to the VTK installation: runtime,
# development, and documentation.  Install rules for each component
# are surrounded by blockers.  Parent projects or users can specify
# VTK_INSTALL_NO_RUNTIME, VTK_INSTALL_NO_DEVELOPMENT, or
# VTK_INSTALL_NO_DOCUMENTATION to avoid installation of the
# corresponding component.

# Shared libraries are considered both runtime and development and
# static libraries are considered development only.  In order to
# switch library installation on and off correctly we make the
# decision here.
SET(VTK_INSTALL_NO_LIBRARIES)
IF(BUILD_SHARED_LIBS)
  IF(VTK_INSTALL_NO_RUNTIME AND VTK_INSTALL_NO_DEVELOPMENT)
    SET(VTK_INSTALL_NO_LIBRARIES 1)
  ENDIF(VTK_INSTALL_NO_RUNTIME AND VTK_INSTALL_NO_DEVELOPMENT)
ELSE(BUILD_SHARED_LIBS)
  IF(VTK_INSTALL_NO_DEVELOPMENT)
    SET(VTK_INSTALL_NO_LIBRARIES 1)
  ENDIF(VTK_INSTALL_NO_DEVELOPMENT)
ENDIF(BUILD_SHARED_LIBS)

# Because INSTALL_* commands require a leading / and because INSTALL (cmake 2.4
# and newer) requires no leading / to install under INSTALL_PREFIX, we
# are stripping the leading /. In the future, there should be no leading
# / in any install directory variables
STRING(REGEX REPLACE "^/" "" VTK_INSTALL_LIB_DIR_CM24 "${VTK_INSTALL_LIB_DIR}")
STRING(REGEX REPLACE "^/" "" VTK_INSTALL_BIN_DIR_CM24 "${VTK_INSTALL_BIN_DIR}")
STRING(REGEX REPLACE "^/" "" VTK_INSTALL_INCLUDE_DIR_CM24 "${VTK_INSTALL_INCLUDE_DIR}")
STRING(REGEX REPLACE "^/" "" VTK_INSTALL_PACKAGE_DIR_CM24 "${VTK_INSTALL_PACKAGE_DIR}")
STRING(REGEX REPLACE "^/" "" VTK_INSTALL_DOXYGEN_DIR_CM24 "${VTK_INSTALL_DOXYGEN_DIR}")
STRING(REGEX REPLACE "^/" "" VTK_INSTALL_DOC_DIR_CM24 "${VTK_INSTALL_DOC_DIR}")
STRING(REGEX REPLACE "^/" "" VTK_INSTALL_TCL_DIR_CM24 "${VTK_INSTALL_TCL_DIR}")
STRING(REGEX REPLACE "^/" "" VTK_INSTALL_JAVA_DIR_CM24 "${VTK_INSTALL_JAVA_DIR}")

#-----------------------------------------------------------------------------
# Save the compiler settings so another project can import them.
CMAKE_EXPORT_BUILD_SETTINGS(${VTK_BINARY_DIR}/VTKBuildSettings.cmake)
IF(NOT VTK_INSTALL_NO_DEVELOPMENT)
  INSTALL(FILES "${VTK_BINARY_DIR}/VTKBuildSettings.cmake"
    DESTINATION ${VTK_INSTALL_PACKAGE_DIR_CM24}
    COMPONENT Development)
ENDIF(NOT VTK_INSTALL_NO_DEVELOPMENT)

#-----------------------------------------------------------------------------
# Provide compatibility options.
OPTION(VTK_LEGACY_REMOVE "Remove all legacy code completely." OFF)
OPTION(VTK_LEGACY_SILENT "Silence all legacy code messages." OFF)
MARK_AS_ADVANCED(VTK_LEGACY_REMOVE VTK_LEGACY_SILENT)

#-----------------------------------------------------------------------------
OPTION(VTK_USE_METAIO "Build metaio" ON)
MARK_AS_ADVANCED(VTK_USE_METAIO)

# Determine the set of VTK kits that should be built.
OPTION(VTK_USE_RENDERING "Build the vtkRendering kit.  Needed for displaying data or using widgets." ON)
VTK_DEPENDENT_OPTION(VTK_USE_PARALLEL "Build the vtkParallel kit." OFF "" OFF)

VTK_DEPENDENT_OPTION(VTK_USE_INFOVIS "Build the vtkInfovis kit.  Needed for performing information visualization." ON "VTK_USE_RENDERING" OFF)

VTK_DEPENDENT_OPTION(VTK_USE_VIEWS "Build the vtkViews kit.  Needed for creating packaged and linked views." ON "VTK_USE_INFOVIS" OFF)

# Determine Shading Support
VTK_DEPENDENT_OPTION(VTK_USE_CG_SHADERS "Build pixel and vertex shader support for Cg." OFF
                     "VTK_USE_RENDERING" OFF)
VTK_DEPENDENT_OPTION(VTK_USE_GLSL_SHADERS "Build pixel and vertex shader support for GLSL." ON
                     "VTK_USE_RENDERING" OFF)

SET(VTK_DEFAULT_SHADERS_DIR
   "${VTK_BINARY_DIR}/Utilities/MaterialLibrary/Repository"
   CACHE INTERNAL 
   "The directory in which code for Shaders is provided.")

SET(VTK_MATERIALS_DIRS 
  ${VTK_DEFAULT_SHADERS_DIR}
  CACHE STRING
  "; separated directories to search for materials/shaders")

MARK_AS_ADVANCED(VTK_USE_CG_SHADERS VTK_USE_GLSL_SHADERS VTK_MATERIALS_DIRS)

# Python multithreading support
SET(_DEFAULT_SKIP_PYTHON_MULTITHREADING_SUPPORT 0)
IF(CMAKE_SYSTEM MATCHES BlueGene  OR  CMAKE_SYSTEM MATCHES Catamount)
  SET(_DEFAULT_SKIP_PYTHON_MULTITHREADING_SUPPORT 1)
ENDIF(CMAKE_SYSTEM MATCHES BlueGene  OR  CMAKE_SYSTEM MATCHES Catamount)
OPTION(VTK_NO_PYTHON_THREADS "Disable multithreading support in the Python bindings" ${_DEFAULT_SKIP_PYTHON_MULTITHREADING_SUPPORT})
MARK_AS_ADVANCED(VTK_NO_PYTHON_THREADS)
  
# Determine GUI Support.
VTK_DEPENDENT_OPTION(VTK_USE_GUISUPPORT "Build VTK with GUI Support" OFF
                     "VTK_USE_RENDERING" OFF)
MARK_AS_ADVANCED(VTK_USE_GUISUPPORT)

# Remove old options from an existing cache.
IF(NOT "VTK_USE_HYBRID" MATCHES "^VTK_USE_HYBRID$")
  SET(VTK_USE_HYBRID "" CACHE INTERNAL "Hiding old option")
ENDIF(NOT "VTK_USE_HYBRID" MATCHES "^VTK_USE_HYBRID$")
IF(NOT "VTK_USE_PATENTED" MATCHES "^VTK_USE_PATENTED$")
  SET(VTK_USE_PATENTED "" CACHE INTERNAL "Hiding old option")
ENDIF(NOT "VTK_USE_PATENTED" MATCHES "^VTK_USE_PATENTED$")
IF(NOT "VTK_USE_VOLUMERENDERING" MATCHES "^VTK_USE_VOLUMERENDERING$")
  SET(VTK_USE_VOLUMERENDERING "" CACHE INTERNAL "Hiding old option")
ENDIF(NOT "VTK_USE_VOLUMERENDERING" MATCHES "^VTK_USE_VOLUMERENDERING$")

SET(VTK_KITS COMMON FILTERING IO GRAPHICS GENERIC_FILTERING IMAGING)

IF(VTK_USE_RENDERING)
  SET(VTK_KITS ${VTK_KITS} RENDERING)
  SET(VTK_KITS ${VTK_KITS} VOLUMERENDERING)
  SET(VTK_KITS ${VTK_KITS} HYBRID)
  SET(VTK_KITS ${VTK_KITS} WIDGETS)
ENDIF(VTK_USE_RENDERING)

IF(VTK_USE_PARALLEL)
  SET(VTK_KITS ${VTK_KITS} PARALLEL)
ENDIF(VTK_USE_PARALLEL)

IF(VTK_USE_INFOVIS)
  SET(VTK_KITS ${VTK_KITS} INFOVIS)
ENDIF(VTK_USE_INFOVIS)

IF(VTK_USE_VIEWS)
  SET(VTK_KITS ${VTK_KITS} VIEWS)
ENDIF(VTK_USE_VIEWS)

# from GUISupport
IF(VTK_USE_QVTK)
  SET(VTK_KITS ${VTK_KITS} QVTK)
ENDIF(VTK_USE_QVTK)

IF(VTK_USE_MFC)
  SET(VTK_KITS ${VTK_KITS} MFC)
ENDIF(VTK_USE_MFC)


#-----------------------------------------------------------------------------
# Determine GUI.

IF (NOT VTK_DONT_INCLUDE_USE_X)
  # We moved VTK_USE_X option code into a separate file so that
  # projects including VTK can include this cmake script and use
  # the option themselves, in which case, they set the VTK_DONT_INCLUDE_USE_X
  # variable to ensure that VTK doesn't set up the option again.
  INCLUDE(${VTK_CMAKE_DIR}/vtkUseX.cmake)
ENDIF (NOT VTK_DONT_INCLUDE_USE_X)

VTK_DEPENDENT_OPTION(VTK_USE_CARBON "Build classes using Carbon API." OFF
                     "APPLE;VTK_USE_RENDERING" OFF)
VTK_DEPENDENT_OPTION(VTK_USE_COCOA "Build classes using Cocoa API." ON
                     "APPLE;VTK_USE_RENDERING" OFF)

IF(VTK_USE_CARBON AND VTK_USE_COCOA)
  MESSAGE(SEND_ERROR "Only one of VTK_USE_CARBON and VTK_USE_COCOA may be ON.")
  SET(VTK_USE_CARBON 0)
  SET(VTK_USE_COCOA 0)
ENDIF(VTK_USE_CARBON AND VTK_USE_COCOA)

#-----------------------------------------------------------------------------
# VTK requires special compiler flags on some platforms.
INCLUDE(${VTK_CMAKE_DIR}/vtkDetermineCompilerFlags.cmake)

# Tell VTK source files they are being built inside VTK.
ADD_DEFINITIONS(-DVTK_IN_VTK)

#-----------------------------------------------------------------------------
# Platform configuration tests.
INCLUDE(${VTK_CMAKE_DIR}/CMakeBackwardCompatibilityC.cmake)
INCLUDE(TestForANSIStreamHeaders)
INCLUDE(TestForSTDNamespace)
INCLUDE(TestForANSIForScope)
INCLUDE(CheckTypeSize)

# Simulate old CMakeBackwardCompatibilityCXX test.
INCLUDE(${CMAKE_ROOT}/Modules/TestForSSTREAM.cmake)

# Tests for various integer, bool and float types
INCLUDE(${VTK_CMAKE_DIR}/vtkTestTypes.cmake)

# Socket tests etc.
INCLUDE(Parallel/VTKParallelCMakeTests.cmake)

# Check for full template specialization support by compiler.
INCLUDE(${VTK_CMAKE_DIR}/vtkTestFullSpecialization.cmake)

# Check for explicit template instantiation support by compiler.
INCLUDE(${VTK_CMAKE_DIR}/vtkTestExplicitInstantiation.cmake)

# Setup clean configuration of vtkConfigure.h and vtkToolkits.h.
MACRO(VTK_PREPARE_CMAKEDEFINE not invar outvar)
  IF(${not} ${invar})
    SET(${outvar} 1)
  ELSE(${not} ${invar})
    SET(${outvar})
  ENDIF(${not} ${invar})
ENDMACRO(VTK_PREPARE_CMAKEDEFINE)

VTK_PREPARE_CMAKEDEFINE("" CMAKE_WORDS_BIGENDIAN VTK_WORDS_BIGENDIAN)
VTK_PREPARE_CMAKEDEFINE("" CMAKE_USE_PTHREADS VTK_USE_PTHREADS)
VTK_PREPARE_CMAKEDEFINE("" CMAKE_USE_SPROC VTK_USE_SPROC)
VTK_PREPARE_CMAKEDEFINE("" CMAKE_HP_PTHREADS VTK_HP_PTHREADS)
VTK_PREPARE_CMAKEDEFINE("" CMAKE_USE_WIN32_THREADS VTK_USE_WIN32_THREADS)
VTK_PREPARE_CMAKEDEFINE("" CMAKE_NO_ANSI_STRING_STREAM VTK_NO_ANSI_STRING_STREAM)
VTK_PREPARE_CMAKEDEFINE("" CMAKE_NO_STD_NAMESPACE VTK_NO_STD_NAMESPACE)
VTK_PREPARE_CMAKEDEFINE(NOT CMAKE_ANSI_FOR_SCOPE VTK_NO_FOR_SCOPE)
VTK_PREPARE_CMAKEDEFINE(NOT VTK_EXPLICIT_TEMPLATES
                  VTK_NO_EXPLICIT_TEMPLATE_INSTANTIATION)
VTK_PREPARE_CMAKEDEFINE(NOT VTK_COMPILER_HAS_FULL_SPECIALIZATION
                        VTK_NO_FULL_TEMPLATE_SPECIALIZATION)

#-----------------------------------------------------------------------------
# Include file dependency tracking regular expression.
SET(VTK_REGEX "vtk[^.]*\\.([^t]|t[^x]|tx[^x]|cxx|hxx)")
IF(VTK_NO_EXPLICIT_TEMPLATE_INSTANTIATION)
  # Track all .txx file dependencies.
  SET(VTK_REGEX_TXX "vtk[^.]*\\.txx")
ELSE(VTK_NO_EXPLICIT_TEMPLATE_INSTANTIATION)
  # Track all .txx file dependencies except *Implicit.txx files.
  SET(VTK_REGEX_TXX "vtk[^.]*([^t]|[^i]t|[^c]it|[^i]cit|[^l]icit|[^p]licit|[^m]plicit|[^I]mplicit)\\.txx")
ENDIF(VTK_NO_EXPLICIT_TEMPLATE_INSTANTIATION)
INCLUDE_REGULAR_EXPRESSION("^((lex|png|j|z|t|D|verdict).*|${VTK_REGEX}|${VTK_REGEX_TXX})$")

#-----------------------------------------------------------------------------
# Determine the set of language wrappers that should be built.
OPTION(VTK_WRAP_TCL "Wrap VTK classes into the TCL language." OFF)
OPTION(VTK_WRAP_PYTHON "Wrap VTK classes into the Python language." OFF)
OPTION(VTK_WRAP_JAVA "Wrap VTK classes into the Java language." OFF)

# Python requires shared libraries.
IF(VTK_WRAP_PYTHON AND VTK_TARGET_SUPPORTS_SHARED_LIBS AND NOT BUILD_SHARED_LIBS )
  MESSAGE(SEND_ERROR "VTK_WRAP_PYTHON requires BUILD_SHARED_LIBS to be ON.")
  SET(VTK_WRAP_PYTHON 0)
ENDIF(VTK_WRAP_PYTHON AND VTK_TARGET_SUPPORTS_SHARED_LIBS AND NOT BUILD_SHARED_LIBS )

# Java requires shared libraries on Windows.
IF(VTK_WRAP_JAVA AND WIN32 AND NOT BUILD_SHARED_LIBS)
  MESSAGE(SEND_ERROR "VTK_WRAP_JAVA requires BUILD_SHARED_LIBS to be ON.")
  SET(VTK_WRAP_JAVA 0)
ENDIF(VTK_WRAP_JAVA AND WIN32 AND NOT BUILD_SHARED_LIBS)

SET(VTK_LANGUAGES "")
IF(VTK_WRAP_TCL)
  SET(VTK_LANGUAGES ${VTK_LANGUAGES} TCL)
ENDIF(VTK_WRAP_TCL)
IF(VTK_WRAP_PYTHON)
  SET(VTK_LANGUAGES ${VTK_LANGUAGES} PYTHON)
ENDIF(VTK_WRAP_PYTHON)
IF(VTK_WRAP_JAVA)
  SET(VTK_LANGUAGES ${VTK_LANGUAGES} JAVA)
ENDIF(VTK_WRAP_JAVA)

#-----------------------------------------------------------------------------
# Configure testing support.
INCLUDE(CTest)
MARK_AS_ADVANCED(DART_ROOT TCL_TCLSH CVSCOMMAND CVS_UPDATE_OPTIONS DART_TESTING_TIMEOUT)
IF(BUILD_TESTING)
  ENABLE_TESTING()
  CONFIGURE_FILE(${VTK_CMAKE_DIR}/CTestCustom.ctest.in
    ${VTK_BINARY_DIR}/CMake/CTestCustom.ctest @ONLY)
  FILE(WRITE ${VTK_BINARY_DIR}/CTestCustom.cmake
    "INCLUDE(\"${VTK_BINARY_DIR}/CMake/CTestCustom.ctest\")\n")
ENDIF(BUILD_TESTING)

OPTION(VTK_USE_DISPLAY "Turn this option off and tests and warning/error macros will not popup windows" ON)
MARK_AS_ADVANCED(VTK_USE_DISPLAY)

#-----------------------------------------------------------------------------
# Leave this option ON by default. It helps to catch floating point math
# exceptions early on nightly dashboard runs.
#
OPTION(VTK_TESTING_USE_FPE "VTK tests call vtkFloatingPointExceptions::Enable()" ON)
MARK_AS_ADVANCED(VTK_TESTING_USE_FPE)

IF(VTK_TESTING_USE_FPE)
 SET(CMAKE_TESTDRIVER_BEFORE_TESTMAIN "vtkFloatingPointExceptions::Enable();\n    try {")
ELSE(VTK_TESTING_USE_FPE)
 SET(CMAKE_TESTDRIVER_BEFORE_TESTMAIN "    try {")
ENDIF(VTK_TESTING_USE_FPE)

SET(CMAKE_TESTDRIVER_AFTER_TESTMAIN "    }
    catch(vtkstd::exception& e)
      {
      fprintf(stderr, \"Test driver caught exception: [%s]\\n\", e.what());
      result = -1;
      }")

#-----------------------------------------------------------------------------
# Select a streams library.

INCLUDE(${VTK_CMAKE_DIR}/vtkSelectStreamsLibrary.cmake)
VTK_SELECT_STREAMS_LIBRARY(VTK_USE_ANSI_STDLIB ${VTK_SOURCE_DIR})
# Check the severity of EOF bugs in the streams library.
# this must be after the test for the long types
INCLUDE(${VTK_CMAKE_DIR}/vtkTestStreamsLibrary.cmake)

IF(VTK_USE_RENDERING AND WIN32)
  # Check for vfw32 support
  INCLUDE(${VTK_CMAKE_DIR}/vtkTestVideoForWindows.cmake)
ENDIF(VTK_USE_RENDERING AND WIN32)

#-----------------------------------------------------------------------------
# Configure KWSys to be named "vtksys".
SET(KWSYS_NAMESPACE vtksys)
SET(KWSYS_USE_Base64 1)
SET(KWSYS_USE_CommandLineArguments 1)
SET(KWSYS_USE_DynamicLoader 1)
SET(KWSYS_USE_Process 1)
SET(KWSYS_USE_RegularExpression 1)
SET(KWSYS_USE_SystemTools 1)
SET(KWSYS_USE_SystemInformation 1)
SET(KWSYS_USE_FundamentalType 1)
SET(KWSYS_USE_Glob 1)
SET(KWSYS_HEADER_ROOT ${VTK_BINARY_DIR}/Utilities)
SET(KWSYS_PROPERTIES_CXX ${VTK_LIBRARY_PROPERTIES})

IF(NOT VTK_USE_ANSI_STDLIB)
  SET(KWSYS_IOS_FORCE_OLD 1)
ENDIF(NOT VTK_USE_ANSI_STDLIB)

IF(NOT VTK_INSTALL_NO_LIBRARIES)
  SET(KWSYS_LIBRARY_INSTALL_DIR ${VTK_INSTALL_LIB_DIR})
  SET(KWSYS_INSTALL_BIN_DIR ${VTK_INSTALL_BIN_DIR_CM24})
  SET(KWSYS_INSTALL_LIB_DIR ${VTK_INSTALL_LIB_DIR_CM24})
  SET(KWSYS_INSTALL_INCLUDE_DIR ${VTK_INSTALL_INCLUDE_DIR_CM24})
  SET(KWSYS_INSTALL_COMPONENT_NAME_RUNTIME RuntimeLibraries)
  SET(KWSYS_INSTALL_COMPONENT_NAME_DEVELOPMENT Development)
ENDIF(NOT VTK_INSTALL_NO_LIBRARIES)
IF(NOT VTK_INSTALL_NO_DEVELOPMENT)
  SET(KWSYS_HEADER_INSTALL_DIR ${VTK_INSTALL_INCLUDE_DIR})
ENDIF(NOT VTK_INSTALL_NO_DEVELOPMENT)

#-----------------------------------------------------------------------------
# Dispatch the build into the proper subdirectories.


SET(VTK_HAS_EXODUS 1)

#-----------------------------------------------------------------------------
# Provide a few configuration options.
OPTION(BUILD_EXAMPLES "Build VTK examples." OFF)

IF("${CMAKE_SIZEOF_VOID_P}" GREATER 4)
 SET(VTK_USE_64BIT_IDS_DEFAULT ON)
ELSE("${CMAKE_SIZEOF_VOID_P}" GREATER 4)
 SET(VTK_USE_64BIT_IDS_DEFAULT OFF)
ENDIF("${CMAKE_SIZEOF_VOID_P}" GREATER 4)
OPTION(VTK_USE_64BIT_IDS "Build VTK with 64 bit ids"
      ${VTK_USE_64BIT_IDS_DEFAULT})

OPTION(VTK_DEBUG_LEAKS "Build leak checking support into VTK." OFF)
MARK_AS_ADVANCED(VTK_DEBUG_LEAKS VTK_USE_64BIT_IDS)

VTK_DEPENDENT_OPTION(VTK_USE_MANGLED_MESA "Use mangled Mesa with OpenGL." OFF
                     "VTK_USE_RENDERING" OFF)
VTK_DEPENDENT_OPTION(VTK_OPENGL_HAS_OSMESA
                     "The opengl library being used supports off screen Mesa calls." OFF
                     "VTK_USE_RENDERING;UNIX" OFF)


# Off-Screen MESA cannot be used with Mangled MESA.
IF(VTK_OPENGL_HAS_OSMESA  AND  VTK_USE_MANGLED_MESA)
  MESSAGE(FATAL_ERROR
    "Off-Screen MESA cannot be used with Mangled MESA.  Turn off either "
    "VTK_OPENGL_HAS_OSMESA or VTK_USE_MANGLED_MESA.")
ENDIF(VTK_OPENGL_HAS_OSMESA  AND  VTK_USE_MANGLED_MESA)


SET(VTK_CAN_DO_OFF_SCREEN)
IF(VTK_USE_MANGLED_MESA OR VTK_OPENGL_HAS_OSMESA OR WIN32)
  SET(VTK_CAN_DO_OFF_SCREEN 1)
ENDIF(VTK_USE_MANGLED_MESA OR VTK_OPENGL_HAS_OSMESA OR WIN32)

VTK_DEPENDENT_OPTION(VTK_USE_OFFSCREEN
                     "Use off screen calls by default." OFF
                     "VTK_CAN_DO_OFF_SCREEN" OFF)
VTK_DEPENDENT_OPTION(VTK_USE_MPI
                     "Use Message Passing Interface (MPI) library for parallel support." OFF
                     "VTK_USE_PARALLEL" OFF)
VTK_DEPENDENT_OPTION(VTK_USE_MATROX_IMAGING
                     "Use Matrox Imaging Library for video input." OFF
                     "VTK_USE_RENDERING;WIN32" OFF)
VTK_DEPENDENT_OPTION(VTK_USE_GL2PS "Build VTK with gl2ps support." OFF
                     "VTK_USE_RENDERING" ON)

SET(VTK_CAN_USE_TK)
IF(VTK_WRAP_PYTHON OR VTK_WRAP_TCL)
  IF(NOT VTK_USE_COCOA  AND NOT  VTK_DISABLE_TK_INIT)
    SET(VTK_CAN_USE_TK 1)
  ENDIF(NOT VTK_USE_COCOA  AND NOT  VTK_DISABLE_TK_INIT)
ENDIF(VTK_WRAP_PYTHON OR VTK_WRAP_TCL)
VTK_DEPENDENT_OPTION(VTK_USE_TK "Build VTK with Tk support" ON
                     "VTK_CAN_USE_TK" OFF)

MARK_AS_ADVANCED(VTK_OPENGL_HAS_OSMESA
                 VTK_USE_OFFSCREEN
                 VTK_USE_TK
                 VTK_USE_GL2PS
                 VTK_USE_MANGLED_MESA
                 VTK_USE_MATROX_IMAGING
                 VTK_USE_MPI)

#-----------------------------------------------------------------------------
# Provide options to use system versions of third-party libraries.
VTK_THIRD_PARTY_OPTION(ZLIB zlib)
VTK_THIRD_PARTY_OPTION(JPEG jpeg)
VTK_THIRD_PARTY_OPTION(PNG  png)
VTK_THIRD_PARTY_OPTION(TIFF tiff)
VTK_THIRD_PARTY_OPTION(EXPAT expat)
VTK_THIRD_PARTY_OPTION(FREETYPE freetype)
VTK_THIRD_PARTY_OPTION(LIBXML2 libxml2)

#-----------------------------------------------------------------------------
# Configure OpenGL support.
IF(VTK_USE_RENDERING)
  # At the moment CMake's FindOpenGL considers OpenGL should be found
  # in the framework version on OSX. This is a reasonable assumption for
  # few people are going to use X. The module warns that if X is to be
  # used, one has to set the libs and include dir manually, which is
  # exactly what we are going to do below.
  IF(APPLE AND VTK_USE_X)
    FIND_PATH(OPENGL_INCLUDE_DIR GL/gl.h 
      /usr/X11R6/include)
    FIND_PATH(OPENGL_xmesa_INCLUDE_DIR GL/xmesa.h 
      /usr/X11R6/include)
    FIND_LIBRARY(OPENGL_gl_LIBRARY NAMES GL MesaGL 
      PATHS /usr/lib /usr/local/lib /usr/X11R6/lib)
    FIND_LIBRARY(OPENGL_glu_LIBRARY NAMES GLU MesaGLU 
      PATHS ${OPENGL_gl_LIBRARY} /usr/lib /usr/local/lib /usr/X11R6/lib)
  ENDIF(APPLE AND VTK_USE_X)
  FIND_PACKAGE(OpenGL)
ENDIF(VTK_USE_RENDERING)

VTK_PREPARE_CMAKEDEFINE("" OPENGL_LIBRARY VTK_USE_OPENGL_LIBRARY)

#-----------------------------------------------------------------------------
# Configure Mangled MESA support.
IF(VTK_USE_MANGLED_MESA)
  FIND_PACKAGE(MangledMesa)

  IF(MANGLED_MESA_INCLUDE_DIR)
    USE_MANGLED_MESA(${MANGLED_MESA_INCLUDE_DIR}/GL
                     ${VTK_BINARY_DIR}/MangleMesaInclude)
  ENDIF(MANGLED_MESA_INCLUDE_DIR)
ENDIF(VTK_USE_MANGLED_MESA)

#-----------------------------------------------------------------------------
# Configure Off-Screen MESA support.
# If rendering is enabled, but there is no graphics system enabled, enforce osmesa
IF(VTK_USE_RENDERING AND NOT WIN32 AND NOT APPLE AND NOT VTK_USE_X)
  SET(VTK_OPENGL_HAS_OSMESA ON CACHE BOOL "Forced to ON since neither OPEN_gl_LIBRARY nor MangledMesa were found" FORCE)
ENDIF(VTK_USE_RENDERING AND NOT WIN32 AND NOT APPLE AND NOT VTK_USE_X)

IF(VTK_OPENGL_HAS_OSMESA)
  FIND_PACKAGE(OSMesa)
ENDIF(VTK_OPENGL_HAS_OSMESA)

#-----------------------------------------------------------------------------
# Configure CG-Shading support.
IF(VTK_USE_CG_SHADERS)
  INCLUDE(${VTK_CMAKE_DIR}/FindCg.cmake)
  MARK_AS_ADVANCED(CG_COMPILER CG_INCLUDE_PATH CG_LIBRARY CG_GL_LIBRARY)
ENDIF(VTK_USE_CG_SHADERS)

#-----------------------------------------------------------------------------
# Configure GLSL-Shading support.
# TODO: Should verify that GL2.0 is supported.

#-----------------------------------------------------------------------------
# Configure Matrox Imaging support.
IF(VTK_USE_MATROX_IMAGING)
  FIND_LIBRARY(MIL_LIBRARY MIL
    "C:/Program Files/Matrox Imaging/mil/library/winnt/msc/dll"
    "C:/Program Files/Matrox Imaging/mil/library/windows/msc/dll"
    )
  FIND_PATH(MIL_INCLUDE_PATH mil.h
    "C:/Program Files/Matrox Imaging/mil/include"
    )
ENDIF(VTK_USE_MATROX_IMAGING)

#-----------------------------------------------------------------------------
# Configure MPI testing support.
# FLAGS used and set for MPI testing
# VTK_MPIRUN_EXE - full path to mpirun command
# VTK_MPI_NUMPROC_FLAG - flag that is used to tell this mpirun how many procs to start
# VTK_MPI_PREFLAGS - flags used directly before process to be run by mpirun
# VTK_MPI_POSTFLAGS - flags used after all other flags by mpirun
# So, tests will be run something like this:
# ${VTK_MPIRUN_EXE} ${VTK_MPI_NUMPROC_FLAG} 2 ${VTK_MPI_PREFLAGS} executable ${VTK_MPI_POSTFLAGS}
#
IF(VTK_USE_MPI AND BUILD_TESTING)
  FIND_PROGRAM(VTK_MPIRUN_EXE NAMES mpirun lamexec PATHS "C:/Program Files/MPICH/mpd/bin")
  SET(VTK_MPI_NUMPROC_FLAG "-np" CACHE STRING "Flag used by mpi to specify the number of processes, the next option will be the number of processes. (see ${CMAKE_CURRENT_SOURCE_DIR}/CMakeLists.txt for more info.)")
  SET(VTK_MPI_PREFLAGS "" CACHE STRING "These flags will be directly before the executable that is being run by VTK_MPIRUN_EXE. (see ${CMAKE_CURRENT_SOURCE_DIR}/CMakeLists.txt for more info.)")
  SET(VTK_MPI_POSTFLAGS "" CACHE STRING "These flags will come after all flags given to MPIRun.(see ${CMAKE_CURRENT_SOURCE_DIR}/CMakeLists.txt for more info.)")
  SET(VTK_MPI_MAX_NUMPROCS "2" CACHE STRING "Maximum number of processors available to run parallel applications. (see ${CMAKE_CURRENT_SOURCE_DIR}/CMakeLists.txt for more info.)")
  MARK_AS_ADVANCED(
    VTK_MPI_NUMPROC_FLAG VTK_MPIRUN_EXE VTK_MPI_PREFLAGS VTK_MPI_POSTFLAGS VTK_MPI_MAX_NUMPROCS)
  SEPARATE_ARGUMENTS(VTK_MPI_PREFLAGS)
  SEPARATE_ARGUMENTS(VTK_MPI_POSTFLAGS)
ENDIF(VTK_USE_MPI AND BUILD_TESTING)

#-----------------------------------------------------------------------------
# Create STL header wrappers to block warnings in the STL headers.
FOREACH(header
  algorithm
  deque
  exception
  functional
  iterator
  list
  map
  memory
  new
  numeric
  queue
  set
  stack
  stdexcept
  string
  utility
  vector
  )
  SET(VTK_STL_HEADER "${header}")
  CONFIGURE_FILE(${VTK_SOURCE_DIR}/Utilities/vtkstd.h.in
                 ${VTK_BINARY_DIR}/vtkstd/${header} @ONLY IMMEDIATE)
  IF(NOT VTK_INSTALL_NO_DEVELOPMENT)
    INSTALL(FILES ${VTK_BINARY_DIR}/vtkstd/${header}
      DESTINATION ${VTK_INSTALL_INCLUDE_DIR_CM24}/vtkstd
      COMPONENT Development)
  ENDIF(NOT VTK_INSTALL_NO_DEVELOPMENT)
ENDFOREACH(header)

#-----------------------------------------------------------------------------
# VTK utility script locations.
SET(VTK_DOXYGEN_HOME ${VTK_SOURCE_DIR}/Utilities/Doxygen)
SET(VTK_HEADER_TESTING_PY ${VTK_SOURCE_DIR}/Common/Testing/HeaderTesting.py)
SET(VTK_FIND_STRING_TCL ${VTK_SOURCE_DIR}/Common/Testing/Tcl/FindString.tcl)
SET(VTK_PRINT_SELF_CHECK_TCL ${VTK_SOURCE_DIR}/Common/Testing/Tcl/PrintSelfCheck.tcl)
SET(VTK_RT_IMAGE_TEST_TCL ${VTK_SOURCE_DIR}/Common/Testing/Tcl/rtImageTest.tcl)
IF(VTK_USE_PARALLEL)
  SET(VTK_PRT_IMAGE_TEST_TCL ${VTK_SOURCE_DIR}/Common/Testing/Tcl/prtImageTest.tcl)
ENDIF(VTK_USE_PARALLEL)



#-----------------------------------------------------------------------------
# Configure the python executable for use by testing.
# Python executable is used by some tests whether VTK_WRAP_PYTHON is
# on or not.
# If VTK_WRAP_PYTHON is on, then we need python executable to compile
# scripts.
IF(BUILD_TESTING OR VTK_WRAP_PYTHON)
  FIND_PACKAGE(PythonInterp)
  MARK_AS_ADVANCED(PYTHON_EXECUTABLE)
ENDIF(BUILD_TESTING OR VTK_WRAP_PYTHON)

#-----------------------------------------------------------------------------
# Configure the default VTK_DATA_ROOT for the location of VTKData.
FIND_PATH(VTK_DATA_ROOT VTKData.readme 
  ${VTK_SOURCE_DIR}/VTKData 
  ${VTK_SOURCE_DIR}/../VTKData 
  ${VTK_SOURCE_DIR}/../../VTKData 
  $ENV{VTK_DATA_ROOT})

#-----------------------------------------------------------------------------
# FFMPEG
# If the ffmpeg library is available, use it.
OPTION (VTK_USE_FFMPEG_ENCODER "If the FFMPEG library is available, should VTK use it for saving .avi animation files?" BOOL)
MARK_AS_ADVANCED(VTK_USE_FFMPEG_ENCODER)
IF (VTK_USE_FFMPEG_ENCODER)
  INCLUDE(${VTK_CMAKE_DIR}/FindFFMPEG.cmake OPTIONAL)
ENDIF (VTK_USE_FFMPEG_ENCODER)

#-----------------------------------------------------------------------------
# MPEG2
#
# Portions of the mpeg2 library are patented. VTK does not enable linking to
# this library by default so VTK can remain "patent free". Users who wish to
# link in mpeg2 functionality must build that library separately and then
# turn on VTK_USE_MPEG2_ENCODER when configuring VTK. After turning on
# VTK_USE_MPEG2_ENCODER, you must also set the CMake variables
# vtkMPEG2Encode_INCLUDE_PATH and vtkMPEG2Encode_LIBRARIES.
#
# To use the patented mpeg2 library, first build it, then set the following
# CMake variables during the VTK configure step:
#   VTK_USE_MPEG2_ENCODER = ON
#   vtkMPEG2Encode_INCLUDE_PATH = /path/to/vtkmpeg2encode;/path/to/vtkmpeg2encode-bin
#   vtkMPEG2Encode_LIBRARIES = /path/to/vtkmpeg2encode-bin/vtkMPEG2Encode.lib
#
# Or using -D args on the cmake/ccmake command line:
#   -DVTK_USE_MPEG2_ENCODER:BOOL=ON
#   "-DvtkMPEG2Encode_INCLUDE_PATH:PATH=/path/to/vtkmpeg2encode;/path/to/vtkmpeg2encode-bin"
#   "-DvtkMPEG2Encode_LIBRARIES:STRING=/path/to/vtkmpeg2encode-bin/vtkMPEG2Encode.lib"
#
# You are solely responsible for any legal issues associated with using
# patented code in your software.
#
OPTION (VTK_USE_MPEG2_ENCODER
  "Enable use of the patented mpeg2 library. You are solely responsible for any legal issues associated with using patented code in your software."
  OFF)
MARK_AS_ADVANCED(VTK_USE_MPEG2_ENCODER)
IF (VTK_USE_MPEG2_ENCODER)
  INCLUDE(${VTK_CMAKE_DIR}/FindMPEG2.cmake OPTIONAL)
ENDIF (VTK_USE_MPEG2_ENCODER)

#-----------------------------------------------------------------------------
# Configure files with settings for use by the build.
CONFIGURE_FILE(${VTK_SOURCE_DIR}/vtkConfigure.h.in
               ${VTK_BINARY_DIR}/vtkConfigure.h @ONLY IMMEDIATE)

CONFIGURE_FILE(${VTK_SOURCE_DIR}/UseVTK.cmake.in
               ${VTK_BINARY_DIR}/UseVTK.cmake COPYONLY IMMEDIATE)

CONFIGURE_FILE(${VTK_SOURCE_DIR}/vtkToolkits.h.in
               ${VTK_BINARY_DIR}/vtkToolkits.h @ONLY)


#-----------------------------------------------------------------------------

IF(VTK_WRAP_TCL OR VTK_WRAP_PYTHON)
  IF(VTK_WRAP_TCL)
    SET(VTK_INCLUDE_NEED_TCL 1)
  ENDIF(VTK_WRAP_TCL)
  IF(VTK_USE_RENDERING AND VTK_USE_TK)
    SET(VTK_INCLUDE_NEED_TK 1)
    SET(VTK_INCLUDE_NEED_TCL 1)
  ENDIF(VTK_USE_RENDERING AND VTK_USE_TK)
ENDIF(VTK_WRAP_TCL OR VTK_WRAP_PYTHON)

#-----------------------------------------------------------------------------
# search Python, Tcl and Java

IF(VTK_WRAP_PYTHON)
  # Tell vtkWrapPython.cmake to set VTK_PYTHON_LIBRARIES for us.
  SET(VTK_WRAP_PYTHON_FIND_LIBS 1)
  INCLUDE("${VTK_CMAKE_DIR}/vtkWrapPython.cmake")
ENDIF(VTK_WRAP_PYTHON)

IF(VTK_WRAP_TCL OR VTK_INCLUDE_NEED_TK)
  # Tell vtkWrapTcl.cmake to set VTK_TCL_LIBRARIES for us.
  SET(VTK_WRAP_TCL_FIND_LIBS 1)
  INCLUDE("${VTK_CMAKE_DIR}/vtkWrapTcl.cmake")
ENDIF(VTK_WRAP_TCL OR VTK_INCLUDE_NEED_TK)

IF(VTK_WRAP_JAVA)
  SET(VTK_WRAP_JAVA3_INIT_DIR "${VTK_SOURCE_DIR}/Wrapping")
  INCLUDE("${VTK_CMAKE_DIR}/vtkWrapJava.cmake")
  FIND_PACKAGE(Java)
  FIND_PACKAGE(JNI)
ENDIF(VTK_WRAP_JAVA)

#-----------------------------------------------------------------------------
# The entire VTK tree should use the same include path.

# Create the list of include directories needed for VTK header files.
INCLUDE(${VTK_SOURCE_DIR}/vtkIncludeDirectories.cmake)

# This should be the only INCLUDE_DIRECTORIES command in the entire
# tree, except for the CMake, Utilities, and Examples directories.  We
# need to do this in one place to make sure the order is correct.
# (isn't the order now handled automatically by cmake, i.e. build dir before source dir ?, Alex)
INCLUDE_DIRECTORIES(
  ${VTK_INCLUDE_DIRS_BUILD_TREE}
  ${VTK_INCLUDE_DIRS_SOURCE_TREE}
  ${VTK_INCLUDE_DIRS_BUILD_TREE_CXX}
  ${VTK_INCLUDE_DIRS_SYSTEM}
)

#-----------------------------------------------------------------------------
# Allow local additions to this file without CVS conflicts.
INCLUDE(${VTK_BINARY_DIR}/LocalUserOptions.cmake OPTIONAL)
INCLUDE(${VTK_SOURCE_DIR}/LocalUserOptions.cmake OPTIONAL)


# Utility libraries and executables.
ADD_SUBDIRECTORY(Wrapping)

#-----------------------------------------------------------------------------
# Wrapping hints used by all Tcl, Python and Java wrapping
IF(VTK_WRAP_TCL OR VTK_WRAP_PYTHON OR VTK_WRAP_JAVA)
  FIND_FILE(VTK_WRAP_HINTS hints ${VTK_SOURCE_DIR}/Wrapping  NO_CMAKE_FIND_ROOT_PATH)
  MARK_AS_ADVANCED(VTK_WRAP_HINTS)
ENDIF(VTK_WRAP_TCL OR VTK_WRAP_PYTHON OR VTK_WRAP_JAVA)


#-----------------------------------------------------------------------------
# Configure Tcl wrapping support, setup executables
IF(VTK_WRAP_TCL)
  # Wrapping executables.
  IF(CMAKE_CROSSCOMPILING)
    SET(VTK_WRAP_TCL_EXE      vtkWrapTcl)
    SET(VTK_WRAP_TCL_INIT_EXE vtkWrapTclInit)
  ELSE(CMAKE_CROSSCOMPILING)
    GET_TARGET_PROPERTY(VTK_WRAP_TCL_EXE      vtkWrapTcl     LOCATION)
    GET_TARGET_PROPERTY(VTK_WRAP_TCL_INIT_EXE vtkWrapTclInit LOCATION)
  ENDIF(CMAKE_CROSSCOMPILING)

  # VTK tcl executables.
  SET(VTK_EXECUTABLE ${EXECUTABLE_OUTPUT_PATH}/vtk)
  IF(VTK_USE_PARALLEL AND VTK_USE_MPI)
    SET(PVTK_EXECUTABLE ${EXECUTABLE_OUTPUT_PATH}/pvtk)
  ENDIF(VTK_USE_PARALLEL AND VTK_USE_MPI)

  # Tcl package location.
  SET(VTK_TCL_HOME ${VTK_BINARY_DIR}/Wrapping/Tcl)

  OPTION(VTK_TCL_TK_STATIC "Build with static Tcl/Tk support. TCL_LIBRARY and TK_LIBRARY must point to the corresponding Tcl/Tk static libraries (example, tcl84sx.lib, tk84sx.lib)." OFF)
  MARK_AS_ADVANCED(VTK_TCL_TK_STATIC)
ENDIF(VTK_WRAP_TCL)

#-----------------------------------------------------------------------------
# Configure Python wrapping support, setup the wrapper executables
IF(VTK_WRAP_PYTHON)
  IF(CMAKE_CROSSCOMPILING)
    SET(VTK_WRAP_PYTHON_EXE vtkWrapPython)
    SET(VTK_WRAP_PYTHON_INIT_EXE vtkWrapPythonInit)
  ELSE(CMAKE_CROSSCOMPILING)
    GET_TARGET_PROPERTY(VTK_WRAP_PYTHON_EXE vtkWrapPython LOCATION)
    GET_TARGET_PROPERTY(VTK_WRAP_PYTHON_INIT_EXE vtkWrapPythonInit LOCATION)
  ENDIF(CMAKE_CROSSCOMPILING)

  # VTK tcl executables.
  SET(VTK_PYTHON_EXE ${EXECUTABLE_OUTPUT_PATH}/vtkpython)
  IF(VTK_USE_PARALLEL AND VTK_USE_MPI)
    SET(PVTK_PYTHON_EXE ${EXECUTABLE_OUTPUT_PATH}/pvtkpython)
  ENDIF(VTK_USE_PARALLEL AND VTK_USE_MPI)

ENDIF(VTK_WRAP_PYTHON)

#-----------------------------------------------------------------------------
# Configure Java wrapping support, setup executables
IF(VTK_WRAP_JAVA)
  # Wrapping executables.
  IF(CMAKE_CROSSCOMPILING)
    SET(VTK_WRAP_JAVA_EXE  vtkWrapJava)
    SET(VTK_PARSE_JAVA_EXE vtkParseJava)
  ELSE(CMAKE_CROSSCOMPILING)
    GET_TARGET_PROPERTY(VTK_WRAP_JAVA_EXE  vtkWrapJava  LOCATION)
    GET_TARGET_PROPERTY(VTK_PARSE_JAVA_EXE vtkParseJava LOCATION)
  ENDIF(CMAKE_CROSSCOMPILING)

  # Java package location.
  SET(VTK_JAVA_JAR ${LIBRARY_OUTPUT_PATH}/vtk.jar)
  SET(VTK_JAVA_HOME ${VTK_BINARY_DIR}/java/vtk)
  MAKE_DIRECTORY(${VTK_JAVA_HOME})
ENDIF(VTK_WRAP_JAVA)

VTK_PREPARE_CMAKEDEFINE("" JAVA_AWT_INCLUDE_PATH VTK_USE_JAWT)

#-----------------------------------------------------------------------------
# Add the option to use Boost
OPTION(VTK_USE_BOOST "Use Boost libraries for graph algorithms - www.boost.org." OFF)
MARK_AS_ADVANCED(VTK_USE_BOOST)

# Look for Boost only if using Boost
IF(VTK_USE_BOOST)
  FIND_PACKAGE(Boost REQUIRED)
  INCLUDE(${VTK_CMAKE_DIR}/ExtractBoostVersion.cmake)

# We need Boost 1.32 or later
  IF(BOOST_VERSION LESS 103200)
    MESSAGE(SEND_ERROR "Incompatible Boost version.  Boost 1.32.0 or later is required.")
  ENDIF(BOOST_VERSION LESS 103200)
ENDIF(VTK_USE_BOOST)

###################################

ADD_SUBDIRECTORY(Utilities)

# Build the subdirector for each kit.
ADD_SUBDIRECTORY(  Common )
ADD_SUBDIRECTORY(  Filtering )
ADD_SUBDIRECTORY(  Imaging )
ADD_SUBDIRECTORY(  Graphics )
ADD_SUBDIRECTORY(  GenericFiltering )
ADD_SUBDIRECTORY(  IO )

IF(VTK_USE_RENDERING)
  ADD_SUBDIRECTORY(Rendering)
  ADD_SUBDIRECTORY(VolumeRendering)
  ADD_SUBDIRECTORY(Hybrid)
  ADD_SUBDIRECTORY(Widgets)
ENDIF(VTK_USE_RENDERING)
IF(VTK_USE_PARALLEL)
  ADD_SUBDIRECTORY(Parallel)
ENDIF(VTK_USE_PARALLEL)
IF(VTK_USE_INFOVIS)
  ADD_SUBDIRECTORY(Infovis)
ENDIF(VTK_USE_INFOVIS)
IF(VTK_USE_VIEWS)
  ADD_SUBDIRECTORY(Views)
ENDIF(VTK_USE_VIEWS)
IF(VTK_USE_GUISUPPORT)
  ADD_SUBDIRECTORY(GUISupport)
ENDIF(VTK_USE_GUISUPPORT)

# Wrapping.
IF(VTK_WRAP_TCL)
  ADD_SUBDIRECTORY(Wrapping/Tcl)
ENDIF(VTK_WRAP_TCL)
IF(VTK_WRAP_PYTHON)
  ADD_SUBDIRECTORY(Wrapping/Python)
ENDIF(VTK_WRAP_PYTHON)
IF(VTK_WRAP_JAVA)
  ADD_SUBDIRECTORY(Wrapping/Java)
ENDIF(VTK_WRAP_JAVA)

# Testing.
IF(BUILD_TESTING)
  MAKE_DIRECTORY(${VTK_BINARY_DIR}/Testing/Temporary)
  # Build scripts to convert tcl tests to python
  ADD_SUBDIRECTORY(Utilities/vtkTclTest2Py)
  ADD_SUBDIRECTORY(Common/Testing)
  ADD_SUBDIRECTORY(Filtering/Testing)
  ADD_SUBDIRECTORY(Graphics/Testing)
  ADD_SUBDIRECTORY(GenericFiltering/Testing)
  ADD_SUBDIRECTORY(Imaging/Testing)
  ADD_SUBDIRECTORY(IO/Testing)
  IF(VTK_USE_RENDERING)
    ADD_SUBDIRECTORY(Rendering/Testing)
    ADD_SUBDIRECTORY(VolumeRendering/Testing)
    ADD_SUBDIRECTORY(Hybrid/Testing)
    ADD_SUBDIRECTORY(Widgets/Testing)
  ENDIF(VTK_USE_RENDERING)
  IF(VTK_USE_PARALLEL)
    ADD_SUBDIRECTORY(Parallel/Testing)
  ENDIF(VTK_USE_PARALLEL)
  IF(VTK_USE_INFOVIS)
    ADD_SUBDIRECTORY(Infovis/Testing)
  ENDIF(VTK_USE_INFOVIS)
  IF(VTK_USE_VIEWS)
    ADD_SUBDIRECTORY(Views/Testing)
  ENDIF(VTK_USE_VIEWS)
ENDIF(BUILD_TESTING)


# Include the examples if they are enabled.  Note that the in-tree
# build adds tests and a custom target to build the examples project
# in a separate build tree.  The examples are not directly included in
# the VTK build.  Doing so will not work because they are designed to
# be built out-of-tree.
IF(BUILD_EXAMPLES)
  ADD_SUBDIRECTORY(Examples)
ENDIF(BUILD_EXAMPLES)

#-----------------------------------------------------------------------------
# Help other projects use VTK.

IF(NOT VTK_INSTALL_NO_DEVELOPMENT)
  # Install the instantiator headers.
  SET(__inst_files
    ${VTK_BINARY_DIR}/vtkCommonInstantiator.h
    ${VTK_BINARY_DIR}/vtkFilteringInstantiator.h
    ${VTK_BINARY_DIR}/vtkIOInstantiator.h
    ${VTK_BINARY_DIR}/vtkImagingInstantiator.h
    ${VTK_BINARY_DIR}/vtkGraphicsInstantiator.h
    ${VTK_BINARY_DIR}/vtkGenericFilteringInstantiator.h)
  IF(VTK_USE_RENDERING)
    SET(__inst_files ${__inst_files} ${VTK_BINARY_DIR}/vtkRenderingInstantiator.h)
    SET(__inst_files ${__inst_files} ${VTK_BINARY_DIR}/vtkVolumeRenderingInstantiator.h)
    SET(__inst_files ${__inst_files} ${VTK_BINARY_DIR}/vtkHybridInstantiator.h)
    SET(__inst_files ${__inst_files} ${VTK_BINARY_DIR}/vtkWidgetsInstantiator.h)
  ENDIF(VTK_USE_RENDERING)
  IF(VTK_USE_PARALLEL)
    SET(__inst_files ${__inst_files} ${VTK_BINARY_DIR}/vtkParallelInstantiator.h)
  ENDIF(VTK_USE_PARALLEL)
  IF(VTK_USE_INFOVIS)
    SET(__inst_files ${__inst_files} ${VTK_BINARY_DIR}/vtkInfovisInstantiator.h)
  ENDIF(VTK_USE_INFOVIS)
  IF(VTK_USE_VIEWS)
    SET(__inst_files ${__inst_files} ${VTK_BINARY_DIR}/vtkViewsInstantiator.h)
  ENDIF(VTK_USE_VIEWS)

  # Install cmake extensions so user projects can load them.
  INSTALL(FILES ${__inst_files}
    DESTINATION ${VTK_INSTALL_INCLUDE_DIR_CM24}
    COMPONENT Development)

  # Install the instantiator headers.
  SET(__inst_files
    ${VTK_CMAKE_DIR}/vtkMakeInstantiator.cmake
    ${VTK_CMAKE_DIR}/vtkMakeInstantiator.h.in
    ${VTK_CMAKE_DIR}/vtkMakeInstantiator.cxx.in)
  INSTALL(FILES ${__inst_files}
    DESTINATION ${VTK_INSTALL_PACKAGE_DIR_CM24}/CMake
    COMPONENT Development)

ENDIF(NOT VTK_INSTALL_NO_DEVELOPMENT)

# Save library dependencies.
EXPORT_LIBRARY_DEPENDENCIES(${VTK_BINARY_DIR}/VTKLibraryDepends.cmake)


# Install some files.
IF(NOT VTK_INSTALL_NO_DEVELOPMENT)

  INSTALL(FILES
    ${VTK_CMAKE_DIR}/FindTCL.cmake
    ${VTK_CMAKE_DIR}/FindPythonLibs.cmake
    ${VTK_CMAKE_DIR}/FindPackageHandleStandardArgs.cmake
    ${VTK_CMAKE_DIR}/FindPackageHandleStandardArgs2.cmake
    ${VTK_CMAKE_DIR}/vtkTclTkMacros.cmake
    ${VTK_CMAKE_DIR}/vtkExportKit.cmake
    ${VTK_CMAKE_DIR}/vtkKit.cmake.in
    ${VTK_CMAKE_DIR}/vtkWrapTcl.cmake
    ${VTK_CMAKE_DIR}/vtkWrapJava.cmake
    ${VTK_CMAKE_DIR}/vtkWrapPython.cmake
    ${VTK_CMAKE_DIR}/vtkWrapperInit.data.in
    ${VTK_CMAKE_DIR}/VTKVersionMacros.cmake
    DESTINATION ${VTK_INSTALL_PACKAGE_DIR_CM24}/CMake 
    COMPONENT Development
    )

  SET(__inst_files
    ${VTK_BINARY_DIR}/vtkConfigure.h
    ${VTK_BINARY_DIR}/vtkToolkits.h)
  INSTALL(FILES ${__inst_files}
    DESTINATION ${VTK_INSTALL_INCLUDE_DIR_CM24}
    COMPONENT Development)

  SET(__inst_files
    ${VTK_BINARY_DIR}/UseVTK.cmake
    ${VTK_BINARY_DIR}/VTKLibraryDepends.cmake)
  IF(VTK_WRAP_HINTS)
    SET(__inst_files ${__inst_files} ${VTK_WRAP_HINTS})
  ENDIF(VTK_WRAP_HINTS)
  INSTALL(FILES ${__inst_files}
    DESTINATION ${VTK_INSTALL_PACKAGE_DIR_CM24}
    COMPONENT Development)
ENDIF(NOT VTK_INSTALL_NO_DEVELOPMENT)

# Setup CPack
INCLUDE(VTKCPack.cmake)

#-----------------------------------------------------------------------------
# The commands in this directory are intended to be executed as
# the end of the whole configuration process, as a "last step".
# This directory is typically the last SUBDIRS in the main CMakeLists.txt.
ADD_SUBDIRECTORY(Utilities/LastConfigureStep)
