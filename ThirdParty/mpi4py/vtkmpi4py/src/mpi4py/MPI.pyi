# Generated with `python conf/mpistubgen.py`
import sys
from threading import Lock
from typing import (
    Any,
    AnyStr,
    Final,
    Literal,
    NoReturn,
    final,
    overload,
)
if sys.version_info >= (3, 9):
    from collections.abc import (
        Callable,
        Hashable,
        Iterable,
        Iterator,
        Sequence,
        Mapping,
    )
else:
    from typing import (
        Callable,
        Hashable,
        Iterable,
        Iterator,
        Sequence,
        Mapping,
    )
if sys.version_info >= (3, 11):
    from typing import Self
else:
    from typing_extensions import Self
from os import PathLike

UNDEFINED: Final[int] = ...
ANY_SOURCE: Final[int] = ...
ANY_TAG: Final[int] = ...
PROC_NULL: Final[int] = ...
ROOT: Final[int] = ...
BOTTOM: Final[BottomType] = ...
IN_PLACE: Final[InPlaceType] = ...
KEYVAL_INVALID: Final[int] = ...
TAG_UB: Final[int] = ...
IO: Final[int] = ...
WTIME_IS_GLOBAL: Final[int] = ...
UNIVERSE_SIZE: Final[int] = ...
APPNUM: Final[int] = ...
LASTUSEDCODE: Final[int] = ...
WIN_BASE: Final[int] = ...
WIN_SIZE: Final[int] = ...
WIN_DISP_UNIT: Final[int] = ...
WIN_CREATE_FLAVOR: Final[int] = ...
WIN_FLAVOR: Final[int] = ...
WIN_MODEL: Final[int] = ...
SUCCESS: Final[int] = ...
ERR_LASTCODE: Final[int] = ...
ERR_TYPE: Final[int] = ...
ERR_REQUEST: Final[int] = ...
ERR_OP: Final[int] = ...
ERR_GROUP: Final[int] = ...
ERR_INFO: Final[int] = ...
ERR_ERRHANDLER: Final[int] = ...
ERR_SESSION: Final[int] = ...
ERR_COMM: Final[int] = ...
ERR_WIN: Final[int] = ...
ERR_FILE: Final[int] = ...
ERR_BUFFER: Final[int] = ...
ERR_COUNT: Final[int] = ...
ERR_TAG: Final[int] = ...
ERR_RANK: Final[int] = ...
ERR_ROOT: Final[int] = ...
ERR_TRUNCATE: Final[int] = ...
ERR_IN_STATUS: Final[int] = ...
ERR_PENDING: Final[int] = ...
ERR_TOPOLOGY: Final[int] = ...
ERR_DIMS: Final[int] = ...
ERR_ARG: Final[int] = ...
ERR_OTHER: Final[int] = ...
ERR_UNKNOWN: Final[int] = ...
ERR_INTERN: Final[int] = ...
ERR_KEYVAL: Final[int] = ...
ERR_NO_MEM: Final[int] = ...
ERR_INFO_KEY: Final[int] = ...
ERR_INFO_VALUE: Final[int] = ...
ERR_INFO_NOKEY: Final[int] = ...
ERR_SPAWN: Final[int] = ...
ERR_PORT: Final[int] = ...
ERR_SERVICE: Final[int] = ...
ERR_NAME: Final[int] = ...
ERR_PROC_ABORTED: Final[int] = ...
ERR_BASE: Final[int] = ...
ERR_SIZE: Final[int] = ...
ERR_DISP: Final[int] = ...
ERR_ASSERT: Final[int] = ...
ERR_LOCKTYPE: Final[int] = ...
ERR_RMA_CONFLICT: Final[int] = ...
ERR_RMA_SYNC: Final[int] = ...
ERR_RMA_RANGE: Final[int] = ...
ERR_RMA_ATTACH: Final[int] = ...
ERR_RMA_SHARED: Final[int] = ...
ERR_RMA_FLAVOR: Final[int] = ...
ERR_BAD_FILE: Final[int] = ...
ERR_NO_SUCH_FILE: Final[int] = ...
ERR_FILE_EXISTS: Final[int] = ...
ERR_FILE_IN_USE: Final[int] = ...
ERR_AMODE: Final[int] = ...
ERR_ACCESS: Final[int] = ...
ERR_READ_ONLY: Final[int] = ...
ERR_NO_SPACE: Final[int] = ...
ERR_QUOTA: Final[int] = ...
ERR_NOT_SAME: Final[int] = ...
ERR_IO: Final[int] = ...
ERR_UNSUPPORTED_OPERATION: Final[int] = ...
ERR_UNSUPPORTED_DATAREP: Final[int] = ...
ERR_CONVERSION: Final[int] = ...
ERR_DUP_DATAREP: Final[int] = ...
ERR_VALUE_TOO_LARGE: Final[int] = ...
ERR_REVOKED: Final[int] = ...
ERR_PROC_FAILED: Final[int] = ...
ERR_PROC_FAILED_PENDING: Final[int] = ...
ORDER_C: Final[int] = ...
ORDER_FORTRAN: Final[int] = ...
ORDER_F: Final[int] = ...
TYPECLASS_INTEGER: Final[int] = ...
TYPECLASS_REAL: Final[int] = ...
TYPECLASS_COMPLEX: Final[int] = ...
DISTRIBUTE_NONE: Final[int] = ...
DISTRIBUTE_BLOCK: Final[int] = ...
DISTRIBUTE_CYCLIC: Final[int] = ...
DISTRIBUTE_DFLT_DARG: Final[int] = ...
COMBINER_NAMED: Final[int] = ...
COMBINER_DUP: Final[int] = ...
COMBINER_CONTIGUOUS: Final[int] = ...
COMBINER_VECTOR: Final[int] = ...
COMBINER_HVECTOR: Final[int] = ...
COMBINER_INDEXED: Final[int] = ...
COMBINER_HINDEXED: Final[int] = ...
COMBINER_INDEXED_BLOCK: Final[int] = ...
COMBINER_HINDEXED_BLOCK: Final[int] = ...
COMBINER_STRUCT: Final[int] = ...
COMBINER_SUBARRAY: Final[int] = ...
COMBINER_DARRAY: Final[int] = ...
COMBINER_RESIZED: Final[int] = ...
COMBINER_VALUE_INDEX: Final[int] = ...
COMBINER_F90_INTEGER: Final[int] = ...
COMBINER_F90_REAL: Final[int] = ...
COMBINER_F90_COMPLEX: Final[int] = ...
F_SOURCE: Final[int] = ...
F_TAG: Final[int] = ...
F_ERROR: Final[int] = ...
F_STATUS_SIZE: Final[int] = ...
IDENT: Final[int] = ...
CONGRUENT: Final[int] = ...
SIMILAR: Final[int] = ...
UNEQUAL: Final[int] = ...
CART: Final[int] = ...
GRAPH: Final[int] = ...
DIST_GRAPH: Final[int] = ...
UNWEIGHTED: Final[int] = ...
WEIGHTS_EMPTY: Final[int] = ...
COMM_TYPE_SHARED: Final[int] = ...
COMM_TYPE_HW_GUIDED: Final[int] = ...
COMM_TYPE_HW_UNGUIDED: Final[int] = ...
COMM_TYPE_RESOURCE_GUIDED: Final[int] = ...
BSEND_OVERHEAD: Final[int] = ...
BUFFER_AUTOMATIC: Final[BufferAutomaticType] = ...
WIN_FLAVOR_CREATE: Final[int] = ...
WIN_FLAVOR_ALLOCATE: Final[int] = ...
WIN_FLAVOR_DYNAMIC: Final[int] = ...
WIN_FLAVOR_SHARED: Final[int] = ...
WIN_SEPARATE: Final[int] = ...
WIN_UNIFIED: Final[int] = ...
MODE_NOCHECK: Final[int] = ...
MODE_NOSTORE: Final[int] = ...
MODE_NOPUT: Final[int] = ...
MODE_NOPRECEDE: Final[int] = ...
MODE_NOSUCCEED: Final[int] = ...
LOCK_EXCLUSIVE: Final[int] = ...
LOCK_SHARED: Final[int] = ...
MODE_RDONLY: Final[int] = ...
MODE_WRONLY: Final[int] = ...
MODE_RDWR: Final[int] = ...
MODE_CREATE: Final[int] = ...
MODE_EXCL: Final[int] = ...
MODE_DELETE_ON_CLOSE: Final[int] = ...
MODE_UNIQUE_OPEN: Final[int] = ...
MODE_SEQUENTIAL: Final[int] = ...
MODE_APPEND: Final[int] = ...
SEEK_SET: Final[int] = ...
SEEK_CUR: Final[int] = ...
SEEK_END: Final[int] = ...
DISPLACEMENT_CURRENT: Final[int] = ...
DISP_CUR: Final[int] = ...
THREAD_SINGLE: Final[int] = ...
THREAD_FUNNELED: Final[int] = ...
THREAD_SERIALIZED: Final[int] = ...
THREAD_MULTIPLE: Final[int] = ...
VERSION: Final[int] = ...
SUBVERSION: Final[int] = ...
MAX_PROCESSOR_NAME: Final[int] = ...
MAX_ERROR_STRING: Final[int] = ...
MAX_PORT_NAME: Final[int] = ...
MAX_INFO_KEY: Final[int] = ...
MAX_INFO_VAL: Final[int] = ...
MAX_OBJECT_NAME: Final[int] = ...
MAX_DATAREP_STRING: Final[int] = ...
MAX_LIBRARY_VERSION_STRING: Final[int] = ...
MAX_PSET_NAME_LEN: Final[int] = ...
MAX_STRINGTAG_LEN: Final[int] = ...

class Datatype:
    def __new__(cls, datatype: Datatype | None = None) -> Self: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    @classmethod
    def fromhandle(cls, handle: int) -> Datatype: ...
    def free(self) -> None: ...
    def Get_size(self) -> int: ...
    def Get_extent(self) -> tuple[int, int]: ...
    def Dup(self) -> Self: ...
    def Create_contiguous(self, count: int) -> Self: ...
    def Create_vector(self, count: int, blocklength: int, stride: int) -> Self: ...
    def Create_hvector(self, count: int, blocklength: int, stride: int) -> Self: ...
    def Create_indexed(self, blocklengths: Sequence[int], displacements: Sequence[int]) -> Self: ...
    def Create_hindexed(self, blocklengths: Sequence[int], displacements: Sequence[int]) -> Self: ...
    def Create_indexed_block(self, blocklength: int, displacements: Sequence[int]) -> Self: ...
    def Create_hindexed_block(self, blocklength: int, displacements: Sequence[int]) -> Self: ...
    @classmethod
    def Create_struct(cls, blocklengths: Sequence[int], displacements: Sequence[int], datatypes: Sequence[Datatype]) -> Self: ...
    def Create_subarray(self, sizes: Sequence[int], subsizes: Sequence[int], starts: Sequence[int], order: int = ORDER_C) -> Self: ...
    def Create_darray(self, size: int, rank: int, gsizes: Sequence[int], distribs: Sequence[int], dargs: Sequence[int], psizes: Sequence[int], order: int = ORDER_C) -> Self: ...
    @classmethod
    def Get_value_index(cls, value: Datatype, index: Datatype) -> Self: ...
    @classmethod
    def Create_f90_integer(cls, r: int) -> Self: ...
    @classmethod
    def Create_f90_real(cls, p: int, r: int) -> Self: ...
    @classmethod
    def Create_f90_complex(cls, p: int, r: int) -> Self: ...
    @classmethod
    def Match_size(cls, typeclass: int, size: int) -> Self: ...
    def Commit(self) -> Self: ...
    def Free(self) -> None: ...
    def Create_resized(self, lb: int, extent: int) -> Self: ...
    def Get_true_extent(self) -> tuple[int, int]: ...
    def Get_envelope(self) -> tuple[int, int, int, int, int]: ...
    def Get_contents(self) -> tuple[list[int], list[int], list[int], list[Datatype]]: ...
    def decode(self) -> tuple[Datatype, str, dict[str, Any]]: ...
    def Pack(self, inbuf: BufSpec, outbuf: BufSpec, position: int, comm: Comm) -> int: ...
    def Unpack(self, inbuf: BufSpec, position: int, outbuf: BufSpec, comm: Comm) -> int: ...
    def Pack_size(self, count: int, comm: Comm) -> int: ...
    def Pack_external(self, datarep: str, inbuf: BufSpec, outbuf: BufSpec, position: int) -> int: ...
    def Unpack_external(self, datarep: str, inbuf: BufSpec, position: int, outbuf: BufSpec) -> int: ...
    def Pack_external_size(self, datarep: str, count: int) -> int: ...
    def Get_attr(self, keyval: int) -> int | Any | None: ...
    def Set_attr(self, keyval: int, attrval: Any) -> None: ...
    def Delete_attr(self, keyval: int) -> None: ...
    @classmethod
    def Create_keyval(cls, copy_fn: Callable[[Datatype, int, Any], Any] | None = None, delete_fn: Callable[[Datatype, int, Any], None] | None = None, nopython: bool = False) -> int: ...
    @classmethod
    def Free_keyval(cls, keyval: int) -> int: ...
    def Get_name(self) -> str: ...
    def Set_name(self, name: str) -> None: ...
    def py2f(self) -> int: ...
    @classmethod
    def f2py(cls, arg: int) -> Datatype: ...
    def tocode(self) -> str: ...
    @classmethod
    def fromcode(cls, code: str) -> Datatype: ...
    handle: int
    size: int
    extent: int
    lb: int
    ub: int
    true_extent: int
    true_lb: int
    true_ub: int
    envelope: tuple[int, int, int, int, int]
    contents: tuple[list[int], list[int], list[int], list[Datatype]]
    combiner: int
    is_named: bool
    is_predefined: bool
    name: str
    typestr: str
    typechar: str
    Create_dup = Dup
    Resized = Create_resized

DATATYPE_NULL: Final[Datatype] = ...
PACKED: Final[Datatype] = ...
BYTE: Final[Datatype] = ...
AINT: Final[Datatype] = ...
OFFSET: Final[Datatype] = ...
COUNT: Final[Datatype] = ...
CHAR: Final[Datatype] = ...
WCHAR: Final[Datatype] = ...
SIGNED_CHAR: Final[Datatype] = ...
SHORT: Final[Datatype] = ...
INT: Final[Datatype] = ...
LONG: Final[Datatype] = ...
LONG_LONG: Final[Datatype] = ...
UNSIGNED_CHAR: Final[Datatype] = ...
UNSIGNED_SHORT: Final[Datatype] = ...
UNSIGNED: Final[Datatype] = ...
UNSIGNED_LONG: Final[Datatype] = ...
UNSIGNED_LONG_LONG: Final[Datatype] = ...
FLOAT: Final[Datatype] = ...
DOUBLE: Final[Datatype] = ...
LONG_DOUBLE: Final[Datatype] = ...
C_BOOL: Final[Datatype] = ...
INT8_T: Final[Datatype] = ...
INT16_T: Final[Datatype] = ...
INT32_T: Final[Datatype] = ...
INT64_T: Final[Datatype] = ...
UINT8_T: Final[Datatype] = ...
UINT16_T: Final[Datatype] = ...
UINT32_T: Final[Datatype] = ...
UINT64_T: Final[Datatype] = ...
C_COMPLEX: Final[Datatype] = ...
C_FLOAT_COMPLEX: Final[Datatype] = ...
C_DOUBLE_COMPLEX: Final[Datatype] = ...
C_LONG_DOUBLE_COMPLEX: Final[Datatype] = ...
CXX_BOOL: Final[Datatype] = ...
CXX_FLOAT_COMPLEX: Final[Datatype] = ...
CXX_DOUBLE_COMPLEX: Final[Datatype] = ...
CXX_LONG_DOUBLE_COMPLEX: Final[Datatype] = ...
SHORT_INT: Final[Datatype] = ...
INT_INT: Final[Datatype] = ...
TWOINT: Final[Datatype] = ...
LONG_INT: Final[Datatype] = ...
FLOAT_INT: Final[Datatype] = ...
DOUBLE_INT: Final[Datatype] = ...
LONG_DOUBLE_INT: Final[Datatype] = ...
CHARACTER: Final[Datatype] = ...
LOGICAL: Final[Datatype] = ...
INTEGER: Final[Datatype] = ...
REAL: Final[Datatype] = ...
DOUBLE_PRECISION: Final[Datatype] = ...
COMPLEX: Final[Datatype] = ...
DOUBLE_COMPLEX: Final[Datatype] = ...
LOGICAL1: Final[Datatype] = ...
LOGICAL2: Final[Datatype] = ...
LOGICAL4: Final[Datatype] = ...
LOGICAL8: Final[Datatype] = ...
INTEGER1: Final[Datatype] = ...
INTEGER2: Final[Datatype] = ...
INTEGER4: Final[Datatype] = ...
INTEGER8: Final[Datatype] = ...
INTEGER16: Final[Datatype] = ...
REAL2: Final[Datatype] = ...
REAL4: Final[Datatype] = ...
REAL8: Final[Datatype] = ...
REAL16: Final[Datatype] = ...
COMPLEX4: Final[Datatype] = ...
COMPLEX8: Final[Datatype] = ...
COMPLEX16: Final[Datatype] = ...
COMPLEX32: Final[Datatype] = ...
UNSIGNED_INT: Final[Datatype] = ...
SIGNED_SHORT: Final[Datatype] = ...
SIGNED_INT: Final[Datatype] = ...
SIGNED_LONG: Final[Datatype] = ...
SIGNED_LONG_LONG: Final[Datatype] = ...
BOOL: Final[Datatype] = ...
SINT8_T: Final[Datatype] = ...
SINT16_T: Final[Datatype] = ...
SINT32_T: Final[Datatype] = ...
SINT64_T: Final[Datatype] = ...
F_BOOL: Final[Datatype] = ...
F_INT: Final[Datatype] = ...
F_FLOAT: Final[Datatype] = ...
F_DOUBLE: Final[Datatype] = ...
F_COMPLEX: Final[Datatype] = ...
F_FLOAT_COMPLEX: Final[Datatype] = ...
F_DOUBLE_COMPLEX: Final[Datatype] = ...

class Status:
    def __new__(cls, status: Status | None = None) -> Self: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __reduce__(self) -> tuple[Any, tuple[Any, ...], dict[str, Any]]: ...
    def __getstate__(self) -> dict[str, int]: ...
    def __setstate__(self, state: dict[str, int]) -> None: ...
    def Get_source(self) -> int: ...
    def Set_source(self, source: int) -> None: ...
    def Get_tag(self) -> int: ...
    def Set_tag(self, tag: int) -> None: ...
    def Get_error(self) -> int: ...
    def Set_error(self, error: int) -> None: ...
    def Get_count(self, datatype: Datatype = BYTE) -> int: ...
    def Get_elements(self, datatype: Datatype) -> int: ...
    def Set_elements(self, datatype: Datatype, count: int) -> None: ...
    def Is_cancelled(self) -> bool: ...
    def Set_cancelled(self, flag: bool) -> None: ...
    def py2f(self) -> list[int]: ...
    @classmethod
    def f2py(cls, arg: list[int]) -> Self: ...
    source: int
    tag: int
    error: int
    count: int
    cancelled: bool

class Request:
    def __new__(cls, request: Request | None = None) -> Self: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    @classmethod
    def fromhandle(cls, handle: int) -> Request: ...
    def free(self) -> None: ...
    def Wait(self, status: Status | None = None) -> Literal[True]: ...
    def Test(self, status: Status | None = None) -> bool: ...
    def Get_status(self, status: Status | None = None) -> bool: ...
    @classmethod
    def Waitany(cls, requests: Sequence[Request], status: Status | None = None) -> int: ...
    @classmethod
    def Testany(cls, requests: Sequence[Request], status: Status | None = None) -> tuple[int, bool]: ...
    @classmethod
    def Get_status_any(cls, requests: Sequence[Request], status: Status | None = None) -> tuple[int, bool]: ...
    @classmethod
    def Waitall(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> Literal[True]: ...
    @classmethod
    def Testall(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> bool: ...
    @classmethod
    def Get_status_all(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> bool: ...
    @classmethod
    def Waitsome(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> list[int] | None: ...
    @classmethod
    def Testsome(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> list[int] | None: ...
    @classmethod
    def Get_status_some(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> list[int] | None: ...
    def Cancel(self) -> None: ...
    def Free(self) -> None: ...
    def py2f(self) -> int: ...
    @classmethod
    def f2py(cls, arg: int) -> Request: ...
    def wait(self, status: Status | None = None) -> Any: ...
    def test(self, status: Status | None = None) -> tuple[bool, Any | None]: ...
    def get_status(self, status: Status | None = None) -> bool: ...
    @classmethod
    def waitany(cls, requests: Sequence[Request], status: Status | None = None) -> tuple[int, Any]: ...
    @classmethod
    def testany(cls, requests: Sequence[Request], status: Status | None = None) -> tuple[int, bool, Any | None]: ...
    @classmethod
    def get_status_any(cls, requests: Sequence[Request], status: Status | None = None) -> tuple[int, bool]: ...
    @classmethod
    def waitall(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> list[Any]: ...
    @classmethod
    def testall(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> tuple[bool, list[Any] | None]: ...
    @classmethod
    def get_status_all(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> bool: ...
    @classmethod
    def waitsome(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> tuple[list[int] | None, list[Any] | None]: ...
    @classmethod
    def testsome(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> tuple[list[int] | None, list[Any] | None]: ...
    @classmethod
    def get_status_some(cls, requests: Sequence[Request], statuses: list[Status] | None = None) -> list[int] | None: ...
    def cancel(self) -> None: ...
    handle: int

REQUEST_NULL: Final[Request] = ...

class Prequest(Request):
    def __new__(cls, request: Request | None = None) -> Self: ...
    def Start(self) -> None: ...
    @classmethod
    def Startall(cls, requests: list[Prequest]) -> None: ...
    def Pready(self, partition: int) -> None: ...
    def Pready_range(self, partition_low: int, partition_high: int) -> None: ...
    def Pready_list(self, partitions: Sequence[int]) -> None: ...
    def Parrived(self, partition: int) -> bool: ...

class Grequest(Request):
    def __new__(cls, request: Request | None = None) -> Self: ...
    @classmethod
    def Start(cls, query_fn: Callable[..., None] | None = None, free_fn: Callable[..., None] | None = None, cancel_fn: Callable[..., None] | None = None, args: tuple[Any] | None = None, kwargs: dict[str, Any] | None = None) -> Grequest: ...
    def Complete(self) -> None: ...
    def complete(self, obj: Any = None) -> None: ...

class Message:
    def __new__(cls, message: Message | None = None) -> Self: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    @classmethod
    def fromhandle(cls, handle: int) -> Message: ...
    def free(self) -> None: ...
    @classmethod
    def Probe(cls, comm: Comm, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> Self: ...
    @classmethod
    def Iprobe(cls, comm: Comm, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> Self | None: ...
    def Recv(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Irecv(self, buf: BufSpec) -> Request: ...
    @classmethod
    def probe(cls, comm: Comm, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> Self: ...
    @classmethod
    def iprobe(cls, comm: Comm, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> Self | None: ...
    def recv(self, status: Status | None = None) -> Any: ...
    def irecv(self) -> Request: ...
    def py2f(self) -> int: ...
    @classmethod
    def f2py(cls, arg: int) -> Message: ...
    handle: int

MESSAGE_NULL: Final[Message] = ...
MESSAGE_NO_PROC: Final[Message] = ...

class Op:
    def __new__(cls, op: Op | None = None) -> Self: ...
    def __call__(self, x: Any, y: Any) -> Any: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    @classmethod
    def fromhandle(cls, handle: int) -> Op: ...
    def free(self) -> None: ...
    @classmethod
    def Create(cls, function: Callable[[Buffer, Buffer, Datatype], None], commute: bool = False) -> Self: ...
    def Free(self) -> None: ...
    def Is_commutative(self) -> bool: ...
    def Reduce_local(self, inbuf: BufSpec, inoutbuf: BufSpec) -> None: ...
    def py2f(self) -> int: ...
    @classmethod
    def f2py(cls, arg: int) -> Op: ...
    handle: int
    is_commutative: bool
    is_predefined: bool

OP_NULL: Final[Op] = ...
MAX: Final[Op] = ...
MIN: Final[Op] = ...
SUM: Final[Op] = ...
PROD: Final[Op] = ...
LAND: Final[Op] = ...
BAND: Final[Op] = ...
LOR: Final[Op] = ...
BOR: Final[Op] = ...
LXOR: Final[Op] = ...
BXOR: Final[Op] = ...
MAXLOC: Final[Op] = ...
MINLOC: Final[Op] = ...
REPLACE: Final[Op] = ...
NO_OP: Final[Op] = ...

class Group:
    def __new__(cls, group: Group | None = None) -> Self: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    @classmethod
    def fromhandle(cls, handle: int) -> Group: ...
    def free(self) -> None: ...
    def Get_size(self) -> int: ...
    def Get_rank(self) -> int: ...
    def Translate_ranks(self, ranks: Sequence[int] | None = None, group: Group | None = None) -> list[int]: ...
    def Compare(self, group: Group) -> int: ...
    def Dup(self) -> Self: ...
    @classmethod
    def Union(cls, group1: Group, group2: Group) -> Self: ...
    @classmethod
    def Intersection(cls, group1: Group, group2: Group) -> Self: ...
    @classmethod
    def Difference(cls, group1: Group, group2: Group) -> Self: ...
    def Incl(self, ranks: Sequence[int]) -> Self: ...
    def Excl(self, ranks: Sequence[int]) -> Self: ...
    def Range_incl(self, ranks: Sequence[tuple[int, int, int]]) -> Self: ...
    def Range_excl(self, ranks: Sequence[tuple[int, int, int]]) -> Self: ...
    @classmethod
    def Create_from_session_pset(cls, session: Session, pset_name: str) -> Self: ...
    def Free(self) -> None: ...
    def py2f(self) -> int: ...
    @classmethod
    def f2py(cls, arg: int) -> Group: ...
    handle: int
    size: int
    rank: int
    @classmethod  # python/mypy#15717
    def Intersect(cls, group1: Group, group2: Group) -> Self: ...

GROUP_NULL: Final[Group] = ...
GROUP_EMPTY: Final[Group] = ...

class Info:
    def __new__(cls, info: Info | None = None) -> Self: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __iter__(self) -> Iterator[str]: ...
    def __bool__(self) -> bool: ...
    def __len__(self) -> int: ...
    def __getitem__(self, __item: str) -> str: ...
    def __setitem__(self, __item: str, __value: str) -> None: ...
    def __delitem__(self, __item: str) -> None: ...
    def __contains__(self, __value: str) -> bool: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    @classmethod
    def fromhandle(cls, handle: int) -> Info: ...
    def free(self) -> None: ...
    @classmethod
    def Create(cls, items: Info | Mapping[str, str] | Iterable[tuple[str, str]] | None = None) -> Self: ...
    @classmethod
    def Create_env(cls, args: Sequence[str] | None = None) -> Self: ...
    def Free(self) -> None: ...
    def Dup(self) -> Self: ...
    def Get(self, key: str) -> str | None: ...
    def Set(self, key: str, value: str) -> None: ...
    def Delete(self, key: str) -> None: ...
    def Get_nkeys(self) -> int: ...
    def Get_nthkey(self, n: int) -> str: ...
    def py2f(self) -> int: ...
    @classmethod
    def f2py(cls, arg: int) -> Info: ...
    def get(self, key: str, default: str | None = None) -> str | None: ...
    def keys(self) -> list[str]: ...
    def values(self) -> list[str]: ...
    def items(self) -> list[tuple[str, str]]: ...
    def update(self, items: Info | Mapping[str, str] | Iterable[tuple[str, str]] = (), **kwds: str) -> None: ...
    def pop(self, key: str, *default: str) -> str: ...
    def popitem(self) -> tuple[str, str]: ...
    def copy(self) -> Self: ...
    def clear(self) -> None: ...
    handle: int

INFO_NULL: Final[Info] = ...
INFO_ENV: Final[Info] = ...

class Errhandler:
    def __new__(cls, errhandler: Errhandler | None = None) -> Self: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    @classmethod
    def fromhandle(cls, handle: int) -> Errhandler: ...
    def free(self) -> None: ...
    def Free(self) -> None: ...
    def py2f(self) -> int: ...
    @classmethod
    def f2py(cls, arg: int) -> Errhandler: ...
    handle: int

ERRHANDLER_NULL: Final[Errhandler] = ...
ERRORS_RETURN: Final[Errhandler] = ...
ERRORS_ABORT: Final[Errhandler] = ...
ERRORS_ARE_FATAL: Final[Errhandler] = ...

class Session:
    def __new__(cls, session: Session | None = None) -> Self: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    @classmethod
    def fromhandle(cls, handle: int) -> Session: ...
    def free(self) -> None: ...
    @classmethod
    def Init(cls, info: Info = INFO_NULL, errhandler: Errhandler | None = None) -> Self: ...
    def Finalize(self) -> None: ...
    def Get_num_psets(self, info: Info = INFO_NULL) -> int: ...
    def Get_nth_pset(self, n: int, info: Info = INFO_NULL) -> str: ...
    def Get_info(self) -> Info: ...
    def Get_pset_info(self, pset_name: str) -> Info: ...
    def Create_group(self, pset_name: str) -> Group: ...
    def Attach_buffer(self, buf: Buffer | None) -> None: ...
    def Detach_buffer(self) -> Buffer | None: ...
    def Flush_buffer(self) -> None: ...
    def Iflush_buffer(self) -> Request: ...
    @classmethod
    def Create_errhandler(cls, errhandler_fn: Callable[[Session, int], None]) -> Errhandler: ...
    def Get_errhandler(self) -> Errhandler: ...
    def Set_errhandler(self, errhandler: Errhandler) -> None: ...
    def Call_errhandler(self, errorcode: int) -> None: ...
    def py2f(self) -> int: ...
    @classmethod
    def f2py(cls, arg: int) -> Session: ...
    handle: int

SESSION_NULL: Final[Session] = ...

class Comm:
    def __new__(cls, comm: Comm | None = None) -> Self: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    @classmethod
    def fromhandle(cls, handle: int) -> Comm: ...
    def free(self) -> None: ...
    def Get_group(self) -> Group: ...
    def Get_size(self) -> int: ...
    def Get_rank(self) -> int: ...
    def Compare(self, comm: Comm) -> int: ...
    def Clone(self) -> Self: ...
    def Dup(self, info: Info | None = None) -> Self: ...
    def Dup_with_info(self, info: Info) -> Self: ...
    def Idup(self, info: Info | None = None) -> tuple[Self, Request]: ...
    def Idup_with_info(self, info: Info) -> tuple[Self, Request]: ...
    def Create(self, group: Group) -> Comm: ...
    def Split(self, color: int = 0, key: int = 0) -> Comm: ...
    def Split_type(self, split_type: int, key: int = 0, info: Info = INFO_NULL) -> Comm: ...
    def Free(self) -> None: ...
    def Revoke(self) -> None: ...
    def Is_revoked(self) -> bool: ...
    def Get_failed(self) -> Group: ...
    def Ack_failed(self, num_to_ack: int | None = None) -> int: ...
    def Agree(self, flag: int) -> int: ...
    def Iagree(self, flag: Buffer) -> Request: ...
    def Shrink(self) -> Comm: ...
    def Ishrink(self) -> tuple[Comm, Request]: ...
    def Set_info(self, info: Info) -> None: ...
    def Get_info(self) -> Info: ...
    def Attach_buffer(self, buf: Buffer | None) -> None: ...
    def Detach_buffer(self) -> Buffer | None: ...
    def Flush_buffer(self) -> None: ...
    def Iflush_buffer(self) -> Request: ...
    def Send(self, buf: BufSpec, dest: int, tag: int = 0) -> None: ...
    def Recv(self, buf: BufSpec, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> None: ...
    def Sendrecv(self, sendbuf: BufSpec, dest: int, sendtag: int = 0, recvbuf: BufSpec | None = None, source: int = ANY_SOURCE, recvtag: int = ANY_TAG, status: Status | None = None) -> None: ...
    def Sendrecv_replace(self, buf: BufSpec, dest: int, sendtag: int = 0, source: int = ANY_SOURCE, recvtag: int = ANY_TAG, status: Status | None = None) -> None: ...
    def Isend(self, buf: BufSpec, dest: int, tag: int = 0) -> Request: ...
    def Irecv(self, buf: BufSpec, source: int = ANY_SOURCE, tag: int = ANY_TAG) -> Request: ...
    def Isendrecv(self, sendbuf: BufSpec, dest: int, sendtag: int = 0, recvbuf: BufSpec | None = None, source: int = ANY_SOURCE, recvtag: int = ANY_TAG) -> Request: ...
    def Isendrecv_replace(self, buf: BufSpec, dest: int, sendtag: int = 0, source: int = ANY_SOURCE, recvtag: int = ANY_TAG) -> Request: ...
    def Probe(self, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> Literal[True]: ...
    def Iprobe(self, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> bool: ...
    def Mprobe(self, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> Message: ...
    def Improbe(self, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> Message | None: ...
    def Send_init(self, buf: BufSpec, dest: int, tag: int = 0) -> Prequest: ...
    def Recv_init(self, buf: BufSpec, source: int = ANY_SOURCE, tag: int = ANY_TAG) -> Prequest: ...
    def Psend_init(self, buf: BufSpec, partitions: int, dest: int, tag: int = 0, info: Info = INFO_NULL) -> Prequest: ...
    def Precv_init(self, buf: BufSpec, partitions: int, source: int = ANY_SOURCE, tag: int = ANY_TAG, info: Info = INFO_NULL) -> Prequest: ...
    def Bsend(self, buf: BufSpec, dest: int, tag: int = 0) -> None: ...
    def Ssend(self, buf: BufSpec, dest: int, tag: int = 0) -> None: ...
    def Rsend(self, buf: BufSpec, dest: int, tag: int = 0) -> None: ...
    def Ibsend(self, buf: BufSpec, dest: int, tag: int = 0) -> Request: ...
    def Issend(self, buf: BufSpec, dest: int, tag: int = 0) -> Request: ...
    def Irsend(self, buf: BufSpec, dest: int, tag: int = 0) -> Request: ...
    def Bsend_init(self, buf: BufSpec, dest: int, tag: int = 0) -> Request: ...
    def Ssend_init(self, buf: BufSpec, dest: int, tag: int = 0) -> Request: ...
    def Rsend_init(self, buf: BufSpec, dest: int, tag: int = 0) -> Request: ...
    def Barrier(self) -> None: ...
    def Bcast(self, buf: BufSpec, root: int = 0) -> None: ...
    def Gather(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecB | None, root: int = 0) -> None: ...
    def Gatherv(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecV | None, root: int = 0) -> None: ...
    def Scatter(self, sendbuf: BufSpecB | None, recvbuf: BufSpec | InPlace, root: int = 0) -> None: ...
    def Scatterv(self, sendbuf: BufSpecV | None, recvbuf: BufSpec | InPlace, root: int = 0) -> None: ...
    def Allgather(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecB) -> None: ...
    def Allgatherv(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecV) -> None: ...
    def Alltoall(self, sendbuf: BufSpecB | InPlace, recvbuf: BufSpecB) -> None: ...
    def Alltoallv(self, sendbuf: BufSpecV | InPlace, recvbuf: BufSpecV) -> None: ...
    def Alltoallw(self, sendbuf: BufSpecW | InPlace, recvbuf: BufSpecW) -> None: ...
    def Reduce(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec | None, op: Op = SUM, root: int = 0) -> None: ...
    def Allreduce(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, op: Op = SUM) -> None: ...
    def Reduce_scatter_block(self, sendbuf: BufSpecB | InPlace, recvbuf: BufSpec | BufSpecB, op: Op = SUM) -> None: ...
    def Reduce_scatter(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, recvcounts: Sequence[int] | None = None, op: Op = SUM) -> None: ...
    def Ibarrier(self) -> Request: ...
    def Ibcast(self, buf: BufSpec, root: int = 0) -> Request: ...
    def Igather(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecB | None, root: int = 0) -> Request: ...
    def Igatherv(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecV | None, root: int = 0) -> Request: ...
    def Iscatter(self, sendbuf: BufSpecB | None, recvbuf: BufSpec | InPlace, root: int = 0) -> Request: ...
    def Iscatterv(self, sendbuf: BufSpecV | None, recvbuf: BufSpec | InPlace, root: int = 0) -> Request: ...
    def Iallgather(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecB) -> Request: ...
    def Iallgatherv(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecV) -> Request: ...
    def Ialltoall(self, sendbuf: BufSpecB | InPlace, recvbuf: BufSpecB) -> Request: ...
    def Ialltoallv(self, sendbuf: BufSpecV | InPlace, recvbuf: BufSpecV) -> Request: ...
    def Ialltoallw(self, sendbuf: BufSpecW | InPlace, recvbuf: BufSpecW) -> Request: ...
    def Ireduce(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec | None, op: Op = SUM, root: int = 0) -> Request: ...
    def Iallreduce(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, op: Op = SUM) -> Request: ...
    def Ireduce_scatter_block(self, sendbuf: BufSpecB | InPlace, recvbuf: BufSpec | BufSpecB, op: Op = SUM) -> Request: ...
    def Ireduce_scatter(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, recvcounts: Sequence[int] | None = None, op: Op = SUM) -> Request: ...
    def Barrier_init(self, info: Info = INFO_NULL) -> Prequest: ...
    def Bcast_init(self, buf: BufSpec, root: int = 0, info: Info = INFO_NULL) -> Prequest: ...
    def Gather_init(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecB | None, root: int = 0, info: Info = INFO_NULL) -> Prequest: ...
    def Gatherv_init(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecV | None, root: int = 0, info: Info = INFO_NULL) -> Prequest: ...
    def Scatter_init(self, sendbuf: BufSpecB | None, recvbuf: BufSpec | InPlace, root: int = 0, info: Info = INFO_NULL) -> Prequest: ...
    def Scatterv_init(self, sendbuf: BufSpecV | None, recvbuf: BufSpec | InPlace, root: int = 0, info: Info = INFO_NULL) -> Prequest: ...
    def Allgather_init(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecB, info: Info = INFO_NULL) -> Prequest: ...
    def Allgatherv_init(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpecV, info: Info = INFO_NULL) -> Prequest: ...
    def Alltoall_init(self, sendbuf: BufSpecB | InPlace, recvbuf: BufSpecB, info: Info = INFO_NULL) -> Prequest: ...
    def Alltoallv_init(self, sendbuf: BufSpecV | InPlace, recvbuf: BufSpecV, info: Info = INFO_NULL) -> Prequest: ...
    def Alltoallw_init(self, sendbuf: BufSpecW | InPlace, recvbuf: BufSpecW, info: Info = INFO_NULL) -> Prequest: ...
    def Reduce_init(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec | None, op: Op = SUM, root: int = 0, info: Info = INFO_NULL) -> Prequest: ...
    def Allreduce_init(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, op: Op = SUM, info: Info = INFO_NULL) -> Prequest: ...
    def Reduce_scatter_block_init(self, sendbuf: BufSpecB | InPlace, recvbuf: BufSpec | BufSpecB, op: Op = SUM, info: Info = INFO_NULL) -> Prequest: ...
    def Reduce_scatter_init(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, recvcounts: Sequence[int] | None = None, op: Op = SUM, info: Info = INFO_NULL) -> Prequest: ...
    def Is_inter(self) -> bool: ...
    def Is_intra(self) -> bool: ...
    def Get_topology(self) -> int: ...
    @classmethod
    def Get_parent(cls) -> Intercomm: ...
    def Disconnect(self) -> None: ...
    @classmethod
    def Join(cls, fd: int) -> Intercomm: ...
    def Get_attr(self, keyval: int) -> int | Any | None: ...
    def Set_attr(self, keyval: int, attrval: Any) -> None: ...
    def Delete_attr(self, keyval: int) -> None: ...
    @classmethod
    def Create_keyval(cls, copy_fn: Callable[[Comm, int, Any], Any] | None = None, delete_fn: Callable[[Comm, int, Any], None] | None = None, nopython: bool = False) -> int: ...
    @classmethod
    def Free_keyval(cls, keyval: int) -> int: ...
    @classmethod
    def Create_errhandler(cls, errhandler_fn: Callable[[Comm, int], None]) -> Errhandler: ...
    def Get_errhandler(self) -> Errhandler: ...
    def Set_errhandler(self, errhandler: Errhandler) -> None: ...
    def Call_errhandler(self, errorcode: int) -> None: ...
    def Abort(self, errorcode: int = 0) -> NoReturn: ...
    def Get_name(self) -> str: ...
    def Set_name(self, name: str) -> None: ...
    def py2f(self) -> int: ...
    @classmethod
    def f2py(cls, arg: int) -> Comm: ...
    def send(self, obj: Any, dest: int, tag: int = 0) -> None: ...
    def bsend(self, obj: Any, dest: int, tag: int = 0) -> None: ...
    def ssend(self, obj: Any, dest: int, tag: int = 0) -> None: ...
    def recv(self, buf: Buffer | None = None, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> Any: ...
    def sendrecv(self, sendobj: Any, dest: int, sendtag: int = 0, recvbuf: Buffer | None = None, source: int = ANY_SOURCE, recvtag: int = ANY_TAG, status: Status | None = None) -> Any: ...
    def isend(self, obj: Any, dest: int, tag: int = 0) -> Request: ...
    def ibsend(self, obj: Any, dest: int, tag: int = 0) -> Request: ...
    def issend(self, obj: Any, dest: int, tag: int = 0) -> Request: ...
    def irecv(self, buf: Buffer | None = None, source: int = ANY_SOURCE, tag: int = ANY_TAG) -> Request: ...
    def probe(self, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> Literal[True]: ...
    def iprobe(self, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> bool: ...
    def mprobe(self, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> Message: ...
    def improbe(self, source: int = ANY_SOURCE, tag: int = ANY_TAG, status: Status | None = None) -> Message | None: ...
    def barrier(self) -> None: ...
    def bcast(self, obj: Any, root: int = 0) -> Any: ...
    def gather(self, sendobj: Any, root: int = 0) -> list[Any] | None: ...
    def scatter(self, sendobj: Sequence[Any] | None, root: int = 0) -> Any: ...
    def allgather(self, sendobj: Any) -> list[Any]: ...
    def alltoall(self, sendobj: Sequence[Any]) -> list[Any]: ...
    def reduce(self, sendobj: Any, op: Op | Callable[[Any, Any], Any] = SUM, root: int = 0) -> Any | None: ...
    def allreduce(self, sendobj: Any, op: Op | Callable[[Any, Any], Any] = SUM) -> Any: ...
    handle: int
    group: Group
    size: int
    rank: int
    info: Info
    is_inter: bool
    is_intra: bool
    topology: int
    is_topo: bool
    name: str

COMM_NULL: Final[Comm] = ...

class Intracomm(Comm):
    def __new__(cls, comm: Comm | None = None) -> Self: ...
    def Create_group(self, group: Group, tag: int = 0) -> Intracomm: ...
    @classmethod
    def Create_from_group(cls, group: Group, stringtag: str = 'org.mpi4py', info: Info = INFO_NULL, errhandler: Errhandler | None = None) -> Intracomm: ...
    def Create_cart(self, dims: Sequence[int], periods: Sequence[bool] | None = None, reorder: bool = False) -> Cartcomm: ...
    def Create_graph(self, index: Sequence[int], edges: Sequence[int], reorder: bool = False) -> Graphcomm: ...
    def Create_dist_graph_adjacent(self, sources: Sequence[int], destinations: Sequence[int], sourceweights: Sequence[int] | None = None, destweights: Sequence[int] | None = None, info: Info = INFO_NULL, reorder: bool = False) -> Distgraphcomm: ...
    def Create_dist_graph(self, sources: Sequence[int], degrees: Sequence[int], destinations: Sequence[int], weights: Sequence[int] | None = None, info: Info = INFO_NULL, reorder: bool = False) -> Distgraphcomm: ...
    def Create_intercomm(self, local_leader: int, peer_comm: Intracomm, remote_leader: int, tag: int = 0) -> Intercomm: ...
    def Cart_map(self, dims: Sequence[int], periods: Sequence[bool] | None = None) -> int: ...
    def Graph_map(self, index: Sequence[int], edges: Sequence[int]) -> int: ...
    def Scan(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, op: Op = SUM) -> None: ...
    def Exscan(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, op: Op = SUM) -> None: ...
    def Iscan(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, op: Op = SUM) -> Request: ...
    def Iexscan(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, op: Op = SUM) -> Request: ...
    def Scan_init(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, op: Op = SUM, info: Info = INFO_NULL) -> Prequest: ...
    def Exscan_init(self, sendbuf: BufSpec | InPlace, recvbuf: BufSpec, op: Op = SUM, info: Info = INFO_NULL) -> Prequest: ...
    def scan(self, sendobj: Any, op: Op | Callable[[Any, Any], Any] = SUM) -> Any: ...
    def exscan(self, sendobj: Any, op: Op | Callable[[Any, Any], Any] = SUM) -> Any: ...
    def Spawn(self, command: str, args: Sequence[str] | None = None, maxprocs: int = 1, info: Info = INFO_NULL, root: int = 0, errcodes: list[int] | None = None) -> Intercomm: ...
    def Spawn_multiple(self, command: Sequence[str], args: Sequence[Sequence[str]] | None = None, maxprocs: Sequence[int] | None = None, info: Sequence[Info] | Info = INFO_NULL, root: int = 0, errcodes: list[list[int]] | None = None) -> Intercomm: ...
    def Accept(self, port_name: str, info: Info = INFO_NULL, root: int = 0) -> Intercomm: ...
    def Connect(self, port_name: str, info: Info = INFO_NULL, root: int = 0) -> Intercomm: ...

COMM_SELF: Final[Intracomm] = ...
COMM_WORLD: Final[Intracomm] = ...

class Topocomm(Intracomm):
    def __new__(cls, comm: Comm | None = None) -> Self: ...
    def Neighbor_allgather(self, sendbuf: BufSpec, recvbuf: BufSpecB) -> None: ...
    def Neighbor_allgatherv(self, sendbuf: BufSpec, recvbuf: BufSpecV) -> None: ...
    def Neighbor_alltoall(self, sendbuf: BufSpecB, recvbuf: BufSpecB) -> None: ...
    def Neighbor_alltoallv(self, sendbuf: BufSpecV, recvbuf: BufSpecV) -> None: ...
    def Neighbor_alltoallw(self, sendbuf: BufSpecW, recvbuf: BufSpecW) -> None: ...
    def Ineighbor_allgather(self, sendbuf: BufSpec, recvbuf: BufSpecB) -> Request: ...
    def Ineighbor_allgatherv(self, sendbuf: BufSpec, recvbuf: BufSpecV) -> Request: ...
    def Ineighbor_alltoall(self, sendbuf: BufSpecB, recvbuf: BufSpecB) -> Request: ...
    def Ineighbor_alltoallv(self, sendbuf: BufSpecV, recvbuf: BufSpecV) -> Request: ...
    def Ineighbor_alltoallw(self, sendbuf: BufSpecW, recvbuf: BufSpecW) -> Request: ...
    def Neighbor_allgather_init(self, sendbuf: BufSpec, recvbuf: BufSpecB, info: Info = INFO_NULL) -> Prequest: ...
    def Neighbor_allgatherv_init(self, sendbuf: BufSpec, recvbuf: BufSpecV, info: Info = INFO_NULL) -> Prequest: ...
    def Neighbor_alltoall_init(self, sendbuf: BufSpecB, recvbuf: BufSpecB, info: Info = INFO_NULL) -> Prequest: ...
    def Neighbor_alltoallv_init(self, sendbuf: BufSpecV, recvbuf: BufSpecV, info: Info = INFO_NULL) -> Prequest: ...
    def Neighbor_alltoallw_init(self, sendbuf: BufSpecW, recvbuf: BufSpecW, info: Info = INFO_NULL) -> Prequest: ...
    def neighbor_allgather(self, sendobj: Any) -> list[Any]: ...
    def neighbor_alltoall(self, sendobj: list[Any]) -> list[Any]: ...
    degrees: tuple[int, int]
    indegree: int
    outdegree: int
    inoutedges: tuple[list[int], list[int]]
    inedges: list[int]
    outedges: list[int]

class Cartcomm(Topocomm):
    def __new__(cls, comm: Comm | None = None) -> Self: ...
    def Get_dim(self) -> int: ...
    def Get_topo(self) -> tuple[list[int], list[int], list[int]]: ...
    def Get_cart_rank(self, coords: Sequence[int]) -> int: ...
    def Get_coords(self, rank: int) -> list[int]: ...
    def Shift(self, direction: int, disp: int) -> tuple[int, int]: ...
    def Sub(self, remain_dims: Sequence[bool]) -> Cartcomm: ...
    dim: int
    ndim: int
    topo: tuple[list[int], list[int], list[int]]
    dims: list[int]
    periods: list[int]
    coords: list[int]

class Graphcomm(Topocomm):
    def __new__(cls, comm: Comm | None = None) -> Self: ...
    def Get_dims(self) -> tuple[int, int]: ...
    def Get_topo(self) -> tuple[list[int], list[int]]: ...
    def Get_neighbors_count(self, rank: int) -> int: ...
    def Get_neighbors(self, rank: int) -> list[int]: ...
    dims: tuple[int, int]
    nnodes: int
    nedges: int
    topo: tuple[list[int], list[int]]
    index: list[int]
    edges: list[int]
    nneighbors: int
    neighbors: list[int]

class Distgraphcomm(Topocomm):
    def __new__(cls, comm: Comm | None = None) -> Self: ...
    def Get_dist_neighbors_count(self) -> int: ...
    def Get_dist_neighbors(self) -> tuple[list[int], list[int], tuple[list[int], list[int]] | None]: ...

class Intercomm(Comm):
    def __new__(cls, comm: Comm | None = None) -> Self: ...
    @classmethod
    def Create_from_groups(cls, local_group: Group, local_leader: int, remote_group: Group, remote_leader: int, stringtag: str = 'org.mpi4py', info: Info = INFO_NULL, errhandler: Errhandler | None = None) -> Intracomm: ...
    def Get_remote_group(self) -> Group: ...
    def Get_remote_size(self) -> int: ...
    def Merge(self, high: bool = False) -> Intracomm: ...
    remote_group: Group
    remote_size: int

class Win:
    def __new__(cls, win: Win | None = None) -> Self: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    if sys.version_info >= (3, 12):
        def __buffer__(self, __flags: int) -> memoryview: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    @classmethod
    def fromhandle(cls, handle: int) -> Win: ...
    def free(self) -> None: ...
    @classmethod
    def Create(cls, memory: Buffer | Bottom, disp_unit: int = 1, info: Info = INFO_NULL, comm: Intracomm = COMM_SELF) -> Self: ...
    @classmethod
    def Allocate(cls, size: int, disp_unit: int = 1, info: Info = INFO_NULL, comm: Intracomm = COMM_SELF) -> Self: ...
    @classmethod
    def Allocate_shared(cls, size: int, disp_unit: int = 1, info: Info = INFO_NULL, comm: Intracomm = COMM_SELF) -> Self: ...
    def Shared_query(self, rank: int) -> tuple[buffer, int]: ...
    @classmethod
    def Create_dynamic(cls, info: Info = INFO_NULL, comm: Intracomm = COMM_SELF) -> Self: ...
    def Attach(self, memory: Buffer) -> None: ...
    def Detach(self, memory: Buffer) -> None: ...
    def Free(self) -> None: ...
    def Set_info(self, info: Info) -> None: ...
    def Get_info(self) -> Info: ...
    def Get_group(self) -> Group: ...
    def Get_attr(self, keyval: int) -> int | Any | None: ...
    def Set_attr(self, keyval: int, attrval: Any) -> None: ...
    def Delete_attr(self, keyval: int) -> None: ...
    @classmethod
    def Create_keyval(cls, copy_fn: Callable[[Win, int, Any], Any] | None = None, delete_fn: Callable[[Win, int, Any], None] | None = None, nopython: bool = False) -> int: ...
    @classmethod
    def Free_keyval(cls, keyval: int) -> int: ...
    def tomemory(self) -> buffer: ...
    def Put(self, origin: BufSpec, target_rank: int, target: TargetSpec | None = None) -> None: ...
    def Get(self, origin: BufSpec, target_rank: int, target: TargetSpec | None = None) -> None: ...
    def Accumulate(self, origin: BufSpec, target_rank: int, target: TargetSpec | None = None, op: Op = SUM) -> None: ...
    def Get_accumulate(self, origin: BufSpec, result: BufSpec, target_rank: int, target: TargetSpec | None = None, op: Op = SUM) -> None: ...
    def Fetch_and_op(self, origin: BufSpec, result: BufSpec, target_rank: int, target_disp: int = 0, op: Op = SUM) -> None: ...
    def Compare_and_swap(self, origin: BufSpec, compare: BufSpec, result: BufSpec, target_rank: int, target_disp: int = 0) -> None: ...
    def Rput(self, origin: BufSpec, target_rank: int, target: TargetSpec | None = None) -> Request: ...
    def Rget(self, origin: BufSpec, target_rank: int, target: TargetSpec | None = None) -> Request: ...
    def Raccumulate(self, origin: BufSpec, target_rank: int, target: TargetSpec | None = None, op: Op = SUM) -> Request: ...
    def Rget_accumulate(self, origin: BufSpec, result: BufSpec, target_rank: int, target: TargetSpec | None = None, op: Op = SUM) -> Request: ...
    def Fence(self, assertion: int = 0) -> None: ...
    def Start(self, group: Group, assertion: int = 0) -> None: ...
    def Complete(self) -> None: ...
    def Post(self, group: Group, assertion: int = 0) -> None: ...
    def Wait(self) -> Literal[True]: ...
    def Test(self) -> bool: ...
    def Lock(self, rank: int, lock_type: int = LOCK_EXCLUSIVE, assertion: int = 0) -> None: ...
    def Unlock(self, rank: int) -> None: ...
    def Lock_all(self, assertion: int = 0) -> None: ...
    def Unlock_all(self) -> None: ...
    def Flush(self, rank: int) -> None: ...
    def Flush_all(self) -> None: ...
    def Flush_local(self, rank: int) -> None: ...
    def Flush_local_all(self) -> None: ...
    def Sync(self) -> None: ...
    @classmethod
    def Create_errhandler(cls, errhandler_fn: Callable[[Win, int], None]) -> Errhandler: ...
    def Get_errhandler(self) -> Errhandler: ...
    def Set_errhandler(self, errhandler: Errhandler) -> None: ...
    def Call_errhandler(self, errorcode: int) -> None: ...
    def Get_name(self) -> str: ...
    def Set_name(self, name: str) -> None: ...
    def py2f(self) -> int: ...
    @classmethod
    def f2py(cls, arg: int) -> Win: ...
    handle: int
    info: Info
    group: Group
    group_size: int
    group_rank: int
    attrs: tuple[int, int, int]
    flavor: int
    model: int
    name: str

WIN_NULL: Final[Win] = ...

class File:
    def __new__(cls, file: File | None = None) -> Self: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    @classmethod
    def fromhandle(cls, handle: int) -> File: ...
    def free(self) -> None: ...
    @classmethod
    def Open(cls, comm: Intracomm, filename: PathLike[AnyStr] | str | bytes, amode: int = MODE_RDONLY, info: Info = INFO_NULL) -> Self: ...
    def Close(self) -> None: ...
    @classmethod
    def Delete(cls, filename: PathLike[AnyStr] | str | bytes, info: Info = INFO_NULL) -> None: ...
    def Set_size(self, size: int) -> None: ...
    def Preallocate(self, size: int) -> None: ...
    def Get_size(self) -> int: ...
    def Get_amode(self) -> int: ...
    def Get_group(self) -> Group: ...
    def Set_info(self, info: Info) -> None: ...
    def Get_info(self) -> Info: ...
    def Set_view(self, disp: int = 0, etype: Datatype = BYTE, filetype: Datatype | None = None, datarep: str = 'native', info: Info = INFO_NULL) -> None: ...
    def Get_view(self) -> tuple[int, Datatype, Datatype, str]: ...
    def Read_at(self, offset: int, buf: BufSpec, status: Status | None = None) -> None: ...
    def Read_at_all(self, offset: int, buf: BufSpec, status: Status | None = None) -> None: ...
    def Write_at(self, offset: int, buf: BufSpec, status: Status | None = None) -> None: ...
    def Write_at_all(self, offset: int, buf: BufSpec, status: Status | None = None) -> None: ...
    def Iread_at(self, offset: int, buf: BufSpec) -> Request: ...
    def Iread_at_all(self, offset: int, buf: BufSpec) -> Request: ...
    def Iwrite_at(self, offset: int, buf: BufSpec) -> Request: ...
    def Iwrite_at_all(self, offset: int, buf: BufSpec) -> Request: ...
    def Read(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Read_all(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Write(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Write_all(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Iread(self, buf: BufSpec) -> Request: ...
    def Iread_all(self, buf: BufSpec) -> Request: ...
    def Iwrite(self, buf: BufSpec) -> Request: ...
    def Iwrite_all(self, buf: BufSpec) -> Request: ...
    def Seek(self, offset: int, whence: int = SEEK_SET) -> None: ...
    def Get_position(self) -> int: ...
    def Get_byte_offset(self, offset: int) -> int: ...
    def Read_shared(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Write_shared(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Iread_shared(self, buf: BufSpec) -> Request: ...
    def Iwrite_shared(self, buf: BufSpec) -> Request: ...
    def Read_ordered(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Write_ordered(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Seek_shared(self, offset: int, whence: int = SEEK_SET) -> None: ...
    def Get_position_shared(self) -> int: ...
    def Read_at_all_begin(self, offset: int, buf: BufSpec) -> None: ...
    def Read_at_all_end(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Write_at_all_begin(self, offset: int, buf: BufSpec) -> None: ...
    def Write_at_all_end(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Read_all_begin(self, buf: BufSpec) -> None: ...
    def Read_all_end(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Write_all_begin(self, buf: BufSpec) -> None: ...
    def Write_all_end(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Read_ordered_begin(self, buf: BufSpec) -> None: ...
    def Read_ordered_end(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Write_ordered_begin(self, buf: BufSpec) -> None: ...
    def Write_ordered_end(self, buf: BufSpec, status: Status | None = None) -> None: ...
    def Get_type_extent(self, datatype: Datatype) -> int: ...
    def Set_atomicity(self, flag: bool) -> None: ...
    def Get_atomicity(self) -> bool: ...
    def Sync(self) -> None: ...
    @classmethod
    def Create_errhandler(cls, errhandler_fn: Callable[[File, int], None]) -> Errhandler: ...
    def Get_errhandler(self) -> Errhandler: ...
    def Set_errhandler(self, errhandler: Errhandler) -> None: ...
    def Call_errhandler(self, errorcode: int) -> None: ...
    def py2f(self) -> int: ...
    @classmethod
    def f2py(cls, arg: int) -> File: ...
    handle: int
    size: int
    amode: int
    group: Group
    group_size: int
    group_rank: int
    info: Info
    atomicity: bool

FILE_NULL: Final[File] = ...

@final
class buffer:
    @overload
    def __new__(cls) -> Self: ...
    @overload
    def __new__(cls, __buf: Buffer) -> Self: ...
    if sys.version_info >= (3, 12):
        def __buffer__(self, __flags: int) -> memoryview: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, __item: int) -> int: ...
    @overload
    def __getitem__(self, __item: slice) -> buffer: ...
    @overload
    def __setitem__(self, __item: int, __value: int) -> None: ...
    @overload
    def __setitem__(self, __item: slice, __value: Buffer) -> None: ...
    @staticmethod
    def allocate(nbytes: int, clear: bool = False) -> buffer: ...
    @staticmethod
    def frombuffer(obj: Buffer, readonly: bool = False) -> buffer: ...
    @staticmethod
    def fromaddress(address: int, nbytes: int, readonly: bool = False) -> buffer: ...
    def cast(self, format: str, shape: list[int] | tuple[int, ...] = ...) -> memoryview: ...
    def tobytes(self, order: str | None = None) -> bytes: ...
    def toreadonly(self) -> buffer: ...
    def release(self) -> None: ...
    address: int
    obj: Buffer | None
    nbytes: int
    readonly: bool
    format: str
    itemsize: int

memory = buffer

@final
class BufferAutomaticType(int):
    def __new__(cls) -> Self: ...
    if sys.version_info >= (3, 12):
        def __buffer__(self, __flags: int) -> memoryview: ...
    def __reduce__(self) -> str: ...

@final
class BottomType(int):
    def __new__(cls) -> Self: ...
    if sys.version_info >= (3, 12):
        def __buffer__(self, __flags: int) -> memoryview: ...
    def __reduce__(self) -> str: ...

@final
class InPlaceType(int):
    def __new__(cls) -> Self: ...
    if sys.version_info >= (3, 12):
        def __buffer__(self, __flags: int) -> memoryview: ...
    def __reduce__(self) -> str: ...

class Pickle:
    @overload
    def __init__(self,
        dumps: Callable[[Any, int], bytes],
        loads: Callable[[Buffer], Any],
        protocol: int | None = None,
        threshold: int | None = None,
    ) -> None: ...
    @overload
    def __init__(self,
        dumps: Callable[[Any], bytes] | None = None,
        loads: Callable[[Buffer], Any] | None = None,
    ) -> None: ...
    def dumps(self, obj: Any) -> bytes: ...
    def loads(self, data: Buffer) -> Any: ...
    def dumps_oob(self, obj: Any) -> tuple[bytes, list[buffer]]: ...
    def loads_oob(self, data: Buffer, buffers: Iterable[Buffer]) -> Any: ...
    PROTOCOL: int | None
    THRESHOLD: int

pickle: Final[Pickle] = ...

class Exception(RuntimeError):
    def __new__(cls, ierr: int = SUCCESS) -> Self: ...
    def __hash__(self) -> int: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def __int__(self) -> int: ...
    def Get_error_code(self) -> int: ...
    def Get_error_class(self) -> int: ...
    def Get_error_string(self) -> str: ...
    error_code: int
    error_class: int
    error_string: str

def Get_error_class(errorcode: int) -> int: ...
def Get_error_string(errorcode: int) -> str: ...
def Add_error_class() -> int: ...
def Remove_error_class(errorclass: int) -> None: ...
def Add_error_code(errorclass: int) -> int: ...
def Remove_error_code(errorcode: int) -> None: ...
def Add_error_string(errorcode: int, string: str) -> None: ...
def Remove_error_string(errorcode: int) -> None: ...
def Get_address(location: Buffer | Bottom) -> int: ...
def Aint_add(base: int, disp: int) -> int: ...
def Aint_diff(addr1: int, addr2: int) -> int: ...
def Compute_dims(nnodes: int, dims: int | Sequence[int]) -> list[int]: ...
def Attach_buffer(buf: Buffer | None) -> None: ...
def Detach_buffer() -> Buffer | None: ...
def Flush_buffer() -> None: ...
def Iflush_buffer() -> Request: ...
def Open_port(info: Info = INFO_NULL) -> str: ...
def Close_port(port_name: str) -> None: ...
def Publish_name(service_name: str, port_name: str, info: Info = INFO_NULL) -> None: ...
def Unpublish_name(service_name: str, port_name: str, info: Info = INFO_NULL) -> None: ...
def Lookup_name(service_name: str, info: Info = INFO_NULL) -> str: ...
def Register_datarep(datarep: str, read_fn: Callable[[Buffer, Datatype, int, Buffer, int], None], write_fn: Callable[[Buffer, Datatype, int, Buffer, int], None], extent_fn: Callable[[Datatype], int]) -> None: ...
def Alloc_mem(size: int, info: Info = INFO_NULL) -> buffer: ...
def Free_mem(mem: buffer) -> None: ...
def Init() -> None: ...
def Finalize() -> None: ...
def Init_thread(required: int = THREAD_MULTIPLE) -> int: ...
def Query_thread() -> int: ...
def Is_thread_main() -> bool: ...
def Is_initialized() -> bool: ...
def Is_finalized() -> bool: ...
def Get_version() -> tuple[int, int]: ...
def Get_library_version() -> str: ...
def Get_processor_name() -> str: ...
def Get_hw_resource_info() -> Info: ...
def Wtime() -> float: ...
def Wtick() -> float: ...
def Pcontrol(level: int) -> None: ...
def get_vendor() -> tuple[str, tuple[int, int, int]]: ...
def _set_abort_status(status: int) -> None: ...
def _comm_lock(comm: Comm, key: Hashable | None = None) -> Lock: ...
def _comm_lock_table(comm: Comm) -> dict[Hashable, Lock]: ...
def _commctx_intra(comm: Intracomm) -> tuple[Intracomm, int]: ...
def _commctx_inter(comm: Intercomm) -> tuple[Intercomm, int, Intracomm, bool]: ...
def _typecode(datatype: Datatype) -> str | None: ...
def _typealign(datatype: Datatype) -> int | None: ...
def _datatype_create(datatype: Datatype, combiner: str, params: dict[str, Any], free: bool = False) -> Datatype: ...
def _datatype_decode(datatype: Datatype, mark: bool = False) -> tuple[Datatype, str, dict[str, Any]]: ...
def _sizeof(arg: Any) -> int: ...
def _addressof(arg: Any) -> int: ...
def _handleof(arg: Any) -> int: ...

__pyx_capi__: Final[dict[str, Any]] = ...
_typedict: Final[dict[str, Datatype]] = ...
_typedict_c: Final[dict[str, Datatype]] = ...
_typedict_f: Final[dict[str, Datatype]] = ...

from .typing import (  # noqa: E402
    Buffer,
    Bottom,
    InPlace,
    BufSpec,
    BufSpecB,
    BufSpecV,
    BufSpecW,
    TargetSpec,
)
