
#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* end standard C headers. */

#ifndef __cplusplus
extern int isatty(int);
#endif /* __cplusplus */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR)(c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state* YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
 *       access to the local variable yy_act. Since yyless() is a macro, it would break
 *       existing scanners that call yyless() from OUTSIDE yylex.
 *       One obvious solution it to make yy_act a global. I tried that, and saw
 *       a 5% performance hit in a non-yylineno scanner, because yy_act is
 *       normally declared as a register variable-- so it is not worth it.
 */
#define YY_LESS_LINENO(n)                                                                          \
  do                                                                                               \
  {                                                                                                \
    int yyl;                                                                                       \
    for (yyl = n; yyl < yyleng; ++yyl)                                                             \
      if (yytext[yyl] == '\n')                                                                     \
        --yylineno;                                                                                \
  } while (0)
#define YY_LINENO_REWIND_TO(dst)                                                                   \
  do                                                                                               \
  {                                                                                                \
    const char* p;                                                                                 \
    for (p = yy_cp - 1; p >= (dst); --p)                                                           \
      if (*p == '\n')                                                                              \
        --yylineno;                                                                                \
  } while (0)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                                                  \
  do                                                                                               \
  {                                                                                                \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    *yy_cp = (yy_hold_char);                                                                       \
    YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ;        \
    YY_DO_BEFORE_ACTION; /* set up yytext again */                                                 \
  } while (0)
#define unput(c) yyunput(c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
{
  FILE* yy_input_file;

  char* yy_ch_buf;  /* input buffer */
  char* yy_buf_pos; /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  int yy_buf_size;

  /* Number of characters read into yy_ch_buf, not including EOB
   * characters.
   */
  int yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int yy_at_bol;

  int yy_bs_lineno; /**< The line count. */
  int yy_bs_column; /**< The column count. */

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int yy_fill_buffer;

  int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via yyrestart()), so that the user can continue scanning by
   * just pointing yyin at a new input file.
   */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0;          /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0;          /**< capacity of stack. */
static YY_BUFFER_STATE* yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars; /* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char* yy_c_buf_p = NULL;
static int yy_init = 0;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart(FILE* input_file);
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size);
void yy_delete_buffer(YY_BUFFER_STATE b);
void yy_flush_buffer(YY_BUFFER_STATE b);
void yypush_buffer_state(YY_BUFFER_STATE new_buffer);
void yypop_buffer_state(void);

static void yyensure_buffer_stack(void);
static void yy_load_buffer_state(void);
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER)

YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size);
YY_BUFFER_STATE yy_scan_string(const char* yy_str);
YY_BUFFER_STATE yy_scan_bytes(const char* bytes, int len);

void* yyalloc(yy_size_t);
void* yyrealloc(void*, yy_size_t);
void yyfree(void*);

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER)                                                                        \
    {                                                                                              \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;                                  \
  }
#define yy_set_bol(at_bol)                                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER)                                                                        \
    {                                                                                              \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                                                  \
  }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char* yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state(void);
static yy_state_type yy_try_NUL_trans(yy_state_type current_state);
static int yy_get_next_buffer(void);
static void yynoreturn yy_fatal_error(const char* msg);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                                        \
  (yytext_ptr) = yy_bp;                                                                            \
  yyleng = (int)(yy_cp - yy_bp);                                                                   \
  (yy_hold_char) = *yy_cp;                                                                         \
  *yy_cp = '\0';                                                                                   \
  (yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 165
#define YY_END_OF_BUFFER 166
static const flex_int16_t yy_accept[961] = { 0, 0, 0, 166, 164, 128, 129, 129, 163, 164, 163, 163,
  164, 163, 163, 163, 163, 163, 163, 163, 126, 125, 163, 163, 163, 163, 117, 117, 117, 117, 117,
  117, 117, 117, 161, 164, 162, 163, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 163, 128, 13, 13, 15, 163, 164, 128, 156, 0, 16, 0, 135,
  149, 132, 153, 150, 0, 0, 0, 90, 91, 0, 0, 0, 0, 0, 147, 143, 145, 144, 146, 142, 140, 0, 118, 3,
  14, 148, 0, 119, 124, 0,

  0, 0, 0, 0, 125, 125, 125, 160, 134, 131, 133, 139, 157, 155, 158, 136, 117, 117, 117, 0, 0, 117,
  117, 117, 0, 117, 0, 130, 127, 0, 152, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 81,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 151, 154, 128, 13, 15, 0, 0, 15, 15, 3, 12, 0, 17, 0, 18, 0, 0,

  0, 0, 0, 0, 141, 159, 0, 118, 118, 118, 0, 14, 14, 120, 119, 119, 124, 124, 0, 123, 0, 121, 122,
  125, 121, 137, 138, 117, 117, 117, 0, 0, 19, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 79, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 26, 117, 117, 117, 117, 65, 117, 83, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 69, 117, 117, 117, 117,

  117, 117, 117, 117, 117, 85, 0, 12, 15, 2, 12, 12, 6, 12, 0, 0, 17, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0,
  118, 0, 118, 1, 5, 0, 120, 120, 120, 119, 0, 119, 124, 121, 0, 123, 123, 0, 121, 121, 0, 122, 122,
  122, 121, 121, 117, 117, 117, 0, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 20, 117, 117, 30, 117, 25, 117, 117, 117, 117, 117, 117, 117, 117, 47,
  117, 117, 117, 117, 117, 117, 24, 117, 117, 117,

  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 0, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 29, 117, 117, 117, 117, 2, 12, 12, 6, 12, 12, 12, 6, 5, 7, 8, 0, 0,
  18, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 118, 118, 5, 120, 0, 120, 119, 0, 119, 119, 121, 121, 123,
  121, 122, 122, 122, 122, 121, 117, 117, 117, 101, 117, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 88, 70, 117,

  117, 42, 89, 50, 117, 117, 117, 117, 117, 117, 117, 22, 117, 117, 117, 117, 117, 117, 117, 117,
  117, 82, 117, 117, 117, 117, 117, 117, 23, 117, 117, 117, 117, 117, 0, 117, 117, 117, 117, 68,
  117, 117, 48, 117, 64, 117, 117, 117, 117, 117, 12, 12, 6, 7, 8, 12, 12, 12, 5, 7, 8, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 118, 120, 0, 120, 120, 119, 121, 117, 117, 117, 101, 96, 117, 117, 117, 117,
  117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 117, 80,

  87, 117, 117, 117, 117, 117, 117, 66, 21, 117, 117, 59, 54, 55, 117, 117, 117, 117, 84, 117, 117,
  117, 117, 117, 44, 117, 117, 117, 28, 117, 117, 57, 0, 0, 0, 0, 117, 43, 117, 117, 117, 117, 117,
  117, 117, 117, 117, 86, 12, 12, 12, 7, 8, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 117, 117,
  117, 95, 117, 107, 117, 117, 109, 117, 117, 113, 117, 117, 117, 117, 117, 117, 117, 103, 117, 117,
  117, 117, 117, 73, 117, 117, 117, 52, 117, 117, 116,

  117, 117, 45, 117, 0, 117, 117, 117, 34, 34, 117, 117, 0, 0, 0, 0, 0, 0, 99, 99, 117, 117, 62,
  117, 117, 49, 117, 117, 33, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 93, 94, 0, 0, 0, 0, 0, 96, 96,
  37, 104, 105, 117, 117, 117, 117, 117, 117, 110, 117, 117, 117, 31, 32, 117, 117, 72, 117, 67, 98,
  98, 117, 71, 117, 53, 97, 97, 0, 117, 0, 78, 117, 0, 41, 35, 35, 117, 117, 0, 0, 0, 0, 0, 0, 60,
  117, 61, 27, 51, 117,

  12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 108, 117, 117, 117, 117, 117, 117, 117, 56,
  117, 63, 117, 0, 46, 0, 117, 117, 117, 0, 0, 0, 0, 0, 0, 117, 117, 12, 12, 12, 10, 12, 12, 0, 0,
  0, 0, 117, 117, 112, 115, 76, 117, 36, 36, 0, 0, 0, 117, 117, 117, 0, 0, 0, 0, 0, 0, 117, 117, 10,
  12, 12, 10, 12, 12, 0, 4, 117, 117, 117, 117, 0, 0, 0, 117, 117, 74, 0, 0, 0, 0, 0, 0, 117, 117,

  10, 12, 12, 12, 12, 0, 117, 117, 114, 75, 0, 0, 0, 117, 117, 0, 0, 0, 0, 58, 100, 12, 12, 11, 12,
  0, 106, 111, 0, 0, 0, 38, 117, 102, 0, 11, 12, 11, 12, 0, 0, 39, 0, 117, 0, 11, 12, 12, 0, 0, 117,
  12, 9, 0, 40, 77, 9, 9, 9, 0 };

static const YY_CHAR yy_ec[256] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 4, 5, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 7, 8, 9, 1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
  22, 23, 24, 25, 25, 26, 25, 27, 28, 29, 17, 30, 31, 32, 1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
  43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 41, 55, 56, 57, 41, 58, 59, 60, 61, 62, 1, 63, 64,
  65, 66,

  67, 68, 69, 70, 71, 41, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
  90, 17, 1, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91,

  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
  91, 91, 91, 91, 91, 91, 91 };

static const YY_CHAR yy_meta[92] = { 0, 1, 2, 3, 4, 5, 2, 1, 1, 1, 1, 6, 7, 1, 4, 6, 1, 1, 1, 8, 1,
  9, 9, 10, 10, 10, 10, 10, 10, 11, 1, 1, 1, 1, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 1, 13, 12, 12, 12, 12, 12, 12, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 14

};

static const flex_int16_t yy_base[1066] = { 0, 0, 90, 2744, 2745, 92, 2745, 2745, 2712, 89, 71, 90,
  2683, 102, 2745, 2710, 93, 88, 107, 96, 153, 128, 83, 115, 2709, 110, 2690, 0, 2704, 131, 56,
  2729, 150, 2694, 165, 156, 2745, 2704, 149, 111, 114, 124, 132, 88, 131, 132, 2658, 2651, 152,
  126, 134, 2665, 151, 157, 217, 159, 2666, 2654, 161, 243, 2745, 2745, 2670, 222, 2657, 245, 2745,
  206, 0, 2722, 2745, 2745, 2745, 2745, 2745, 214, 157, 255, 2745, 2745, 210, 2697, 233, 212, 226,
  2745, 2745, 2745, 2745, 2745, 2710, 2745, 2705, 257, 249, 267, 2745, 277, 304, 322, 340,

  250, 358, 0, 369, 387, 0, 405, 2745, 2745, 2745, 2745, 2692, 2745, 2745, 2745, 2691, 0, 2679,
  2675, 278, 2660, 2710, 2669, 2687, 2702, 2667, 317, 2745, 2745, 2710, 2745, 233, 2645, 2635, 2631,
  2639, 371, 2637, 2641, 2625, 2624, 2628, 2622, 2639, 2638, 219, 243, 2618, 2624, 2616, 232, 2621,
  2625, 234, 2614, 2619, 2612, 2618, 2607, 254, 2617, 2622, 2626, 2606, 262, 2622, 206, 2609, 249,
  2613, 290, 2609, 2603, 2595, 2603, 365, 364, 2608, 2599, 284, 2605, 2606, 2596, 2745, 2745, 440,
  2745, 2615, 383, 2602, 2613, 397, 440, 451, 265, 0, 416, 0, 2642, 2641,

  359, 267, 325, 409, 2745, 2745, 440, 470, 0, 488, 2639, 0, 2638, 505, 0, 523, 0, 536, 497, 457,
  552, 569, 586, 0, 605, 2745, 2745, 2629, 2621, 2630, 2635, 2650, 2745, 2628, 2590, 2584, 2584,
  2579, 2594, 2577, 2574, 285, 2587, 2590, 2573, 2584, 2569, 2579, 2579, 2585, 2570, 341, 2572,
  2579, 2564, 2562, 2564, 2560, 2566, 2575, 2570, 2572, 2572, 2560, 2560, 2565, 2568, 2563, 2558, 0,
  2549, 2558, 2563, 2558, 0, 2539, 2561, 2549, 2542, 2553, 2540, 2535, 2536, 2543, 2544, 2539, 2534,
  2537, 2544, 2523, 2528, 2579, 388, 2530, 405, 0, 2539, 2529, 2533, 2528,

  2521, 2535, 2537, 2547, 2535, 2535, 473, 549, 417, 2566, 0, 368, 2565, 395, 2517, 2512, 0, 479, 0,
  407, 577, 457, 471, 570, 472, 505, 470, 0, 634, 651, 2745, 0, 643, 668, 0, 686, 0, 660, 703, 0,
  720, 419, 623, 0, 695, 728, 0, 0, 745, 802, 0, 764, 0, 2545, 2556, 2547, 0, 2540, 2519, 2513,
  2519, 2518, 2504, 2492, 2474, 2487, 2452, 2452, 2433, 2449, 2419, 2432, 2414, 2409, 2404, 0, 2395,
  2378, 0, 2386, 543, 2353, 2346, 2332, 2326, 2322, 2318, 2320, 2316, 0, 2314, 2303, 2296, 2299,
  2280, 2274, 0, 2263, 2233, 2234,

  2218, 2194, 2194, 2173, 2178, 2176, 2166, 2156, 2144, 2138, 2132, 440, 2145, 2134, 2127, 2164,
  2112, 2119, 2106, 2113, 2087, 571, 2093, 2094, 2080, 2061, 0, 2056, 2053, 2050, 2059, 2745, 0,
  534, 0, 478, 536, 2048, 0, 0, 0, 0, 2028, 2020, 0, 555, 507, 556, 571, 560, 618, 574, 668, 794,
  737, 821, 0, 0, 0, 772, 850, 867, 829, 875, 0, 892, 0, 0, 0, 909, 966, 0, 0, 0, 2020, 2025, 2007,
  0, 1989, 1942, 1937, 1923, 1915, 1919, 1925, 1903, 1914, 1909, 1898, 1887, 1893, 1875, 1888, 1868,
  1879, 1863, 1873, 0, 0, 1908,

  1908, 0, 0, 638, 1840, 1847, 1850, 1845, 1835, 1835, 1822, 0, 1818, 1811, 1812, 1791, 1786, 1795,
  1783, 1779, 1774, 0, 1778, 1746, 1756, 1753, 1732, 1743, 0, 1732, 1736, 1716, 1734, 1729, 878,
  1720, 1702, 1714, 1708, 0, 1702, 1697, 0, 1671, 0, 1670, 1661, 1665, 1664, 1644, 686, 1649, 0, 0,
  0, 1674, 1656, 1608, 0, 0, 0, 1618, 1584, 589, 773, 880, 672, 876, 802, 877, 619, 938, 958, 985,
  1014, 0, 1031, 0, 1606, 1615, 1607, 0, 1593, 1578, 1575, 1568, 1554, 1563, 1535, 1529, 1526, 1535,
  1517, 1531, 1521, 1515, 1530, 1527, 1511, 0,

  0, 1528, 1527, 1523, 1502, 1509, 1504, 0, 0, 1519, 1512, 0, 0, 0, 1508, 1514, 1517, 1502, 0, 1499,
  1501, 1502, 1504, 1489, 772, 1502, 1489, 1487, 0, 1059, 1485, 1503, 1484, 1481, 1482, 858, 1150,
  0, 1480, 1498, 1491, 1484, 1490, 1483, 1482, 1502, 1472, 0, 1518, 1513, 1470, 0, 0, 1503, 1512,
  1445, 1435, 1440, 590, 985, 1092, 834, 541, 986, 772, 1064, 1087, 1450, 1462, 1452, 0, 1424, 0,
  1438, 1423, 0, 1439, 1436, 0, 1426, 1421, 1434, 1433, 1424, 1421, 1430, 0, 1411, 1410, 1427, 1412,
  1421, 0, 1425, 1405, 1241, 0, 1420, 1399, 1417,

  1399, 1332, 879, 1410, 1022, 1397, 1398, 922, 2745, 0, 1423, 671, 1393, 1400, 1391, 1384, 1399,
  1390, 2745, 0, 1401, 1394, 0, 1399, 1399, 0, 1397, 1382, 0, 1416, 1425, 1395, 1421, 1405, 1378,
  1352, 1355, 775, 572, 1120, 2745, 1388, 1183, 835, 894, 882, 987, 1367, 1366, 0, 0, 0, 1339, 1340,
  1330, 1338, 1343, 1336, 0, 1343, 1334, 1333, 0, 0, 1325, 1325, 0, 1338, 0, 2745, 0, 1335, 0, 1320,
  0, 2745, 0, 1125, 1334, 1325, 0, 1318, 993, 2745, 2745, 0, 1316, 1332, 1310, 1315, 1308, 1319,
  1298, 1313, 0, 1307, 0, 0, 0, 1303,

  1343, 1327, 1300, 1372, 1335, 1303, 1294, 1301, 1188, 1274, 1131, 2745, 883, 1067, 1071, 1072, 0,
  1252, 1246, 1261, 1252, 1243, 1249, 1239, 0, 1256, 0, 1514, 1245, 1042, 1241, 1249, 1235, 1233,
  1245, 1234, 1243, 1247, 1240, 1231, 1240, 1233, 1290, 1250, 1215, 0, 1235, 1201, 1194, 1169, 1114,
  1155, 1170, 1167, 0, 1171, 0, 1152, 2745, 0, 1155, 1213, 1149, 1148, 1160, 1145, 1162, 1143, 1159,
  1140, 1158, 1145, 1150, 1132, 0, 1158, 1127, 0, 1155, 1120, 1132, 2745, 1129, 1080, 1077, 1057,
  1051, 1051, 1036, 52, 154, 0, 216, 291, 379, 0, 506, 0, 561, 634,

  0, 756, 724, 828, 787, 778, 787, 799, 0, 0, 800, 810, 1194, 845, 845, 0, 878, 0, 0, 0, 0, 946,
  896, 0, 892, 898, 0, 0, 1279, 890, 1285, 2745, 934, 0, 936, 0, 942, 0, 944, 944, 1292, 2745, 943,
  966, 0, 0, 974, 1074, 1029, 1365, 1024, 1077, 0, 1370, 2745, 0, 0, 0, 0, 2745, 1605, 1619, 1632,
  1640, 1646, 1660, 1663, 1669, 1677, 1691, 1697, 1705, 1711, 1715, 1729, 1743, 1749, 1752, 1758,
  1766, 1772, 1778, 1786, 1794, 1802, 1810, 1824, 1838, 1844, 1853, 1859, 1867, 1881, 1889, 1895,
  1901, 1909, 1915, 1923, 1931,

  1937, 1945, 1951, 1957, 1963, 1971, 1977, 1985, 1991, 1997, 2000, 2014, 2028, 2042, 2056, 2070,
  2084, 2098, 2104, 2110, 2118, 2126, 2132, 2146, 2152, 2160, 2168, 2176, 2182, 2190, 2196, 2202,
  2208, 2216, 2222, 2228, 2234, 2240, 2254, 2268, 2282, 2296, 2310, 2324, 2338, 2352, 2358, 2366,
  2374, 2382, 2388, 2396, 2402, 2416, 2430, 2444, 2458, 2472, 2486, 2500, 2514, 2528, 2542, 2556,
  2570 };

static const flex_int16_t yy_def[1066] = { 0, 960, 1, 960, 960, 960, 960, 960, 960, 961, 960, 960,
  962, 963, 960, 960, 960, 960, 960, 960, 960, 964, 960, 960, 960, 960, 965, 965, 965, 965, 965,
  965, 965, 965, 960, 960, 960, 960, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965,
  965, 965, 965, 965, 965, 965, 965, 965, 960, 960, 960, 960, 966, 960, 960, 960, 960, 961, 967,
  961, 960, 960, 960, 960, 960, 962, 962, 963, 960, 960, 968, 968, 968, 968, 968, 960, 960, 960,
  960, 960, 960, 960, 960, 969, 960, 970, 960, 960, 971, 972, 960,

  960, 960, 973, 960, 964, 974, 974, 960, 960, 960, 960, 960, 960, 960, 960, 960, 965, 965, 965,
  961, 962, 965, 965, 965, 975, 965, 960, 960, 960, 960, 960, 965, 965, 965, 965, 965, 965, 965,
  965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965,
  965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965,
  965, 965, 965, 965, 965, 965, 965, 960, 960, 960, 960, 966, 960, 960, 966, 966, 960, 976, 960,
  977, 961, 978, 968, 960,

  968, 968, 968, 968, 960, 960, 960, 969, 979, 979, 960, 970, 970, 980, 981, 981, 982, 982, 960,
  983, 960, 984, 985, 974, 986, 960, 960, 965, 965, 965, 960, 975, 960, 965, 965, 965, 965, 965,
  965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965,
  965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965,
  965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 965,
  965, 965, 965, 965, 965,

  965, 965, 965, 965, 965, 965, 960, 987, 966, 960, 976, 976, 988, 976, 960, 960, 977, 961, 989,
  990, 991, 991, 991, 991, 991, 991, 991, 979, 960, 992, 960, 993, 960, 994, 995, 995, 996, 960,
  997, 998, 999, 960, 1000, 1001, 960, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1010,
  1010, 1011, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010,
  1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010,
  1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010,

  1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 960,
  1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 960,
  1012, 1012, 1013, 1012, 1014, 1014, 1015, 1016, 1017, 1018, 960, 960, 1019, 1020, 1020, 1020,
  1020, 1020, 1020, 1020, 1020, 1021, 960, 1022, 1023, 1024, 1025, 960, 1026, 1027, 960, 1028, 1029,
  1030, 1031, 1032, 1033, 1034, 1034, 1035, 1035, 1036, 1037, 1037, 1037, 1038, 1037, 1037, 1037,
  1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037,
  1037, 1037, 1037,

  1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037,
  1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037,
  1037, 1037, 960, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037,
  1037, 1037, 1039, 1039, 1040, 1041, 1042, 1043, 1043, 1043, 1044, 1045, 1046, 960, 960, 1047,
  1047, 1047, 1047, 1047, 1047, 1047, 1047, 1048, 1049, 960, 1050, 1051, 1052, 1053, 1037, 1037,
  1037, 1038, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037,
  1037, 1037, 1037, 1037,

  1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037,
  1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037,
  960, 960, 960, 960, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1039,
  1039, 1039, 1041, 1042, 1043, 1043, 1043, 960, 960, 1047, 1047, 1047, 1047, 1047, 1047, 1047,
  1047, 1049, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037,
  1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037,
  1037, 1037, 1037,

  1037, 1037, 1037, 1037, 960, 1037, 1037, 1037, 960, 1037, 1037, 1037, 960, 960, 960, 960, 960,
  960, 960, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1039, 1039, 1039, 1043,
  1043, 1043, 960, 960, 1047, 1047, 960, 960, 1047, 1047, 1047, 1047, 1047, 1047, 1037, 1037, 1037,
  1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037,
  1037, 1037, 1037, 960, 1037, 1037, 1037, 1037, 1037, 960, 1037, 960, 1037, 960, 1037, 1037, 960,
  960, 960, 1037, 1037, 1037, 960, 960, 960, 960, 960, 960, 1037, 1037, 1037, 1037, 1037, 1037,

  1039, 1039, 1039, 1043, 1043, 1043, 960, 960, 1047, 1047, 960, 960, 1047, 1047, 1047, 1047, 1037,
  1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 960, 1037, 960, 1037, 1037,
  1037, 960, 960, 960, 960, 960, 960, 1037, 1037, 1039, 1039, 1039, 1054, 1043, 1043, 960, 960,
  1047, 1047, 1037, 1037, 1037, 1037, 1037, 1037, 960, 1037, 960, 960, 960, 1037, 1037, 1037, 960,
  960, 960, 960, 960, 960, 1037, 1037, 1055, 1039, 1039, 1054, 1043, 1043, 960, 960, 1037, 1037,
  1037, 1037, 960, 960, 960, 1037, 1037, 1037, 960, 960, 960, 1056, 960, 1057, 1037, 1037,

  1055, 1039, 1039, 1043, 1043, 960, 1037, 1037, 1037, 1037, 960, 960, 960, 1037, 1037, 1058, 960,
  1059, 1060, 1037, 1037, 1039, 1039, 1061, 1043, 960, 1037, 1037, 960, 960, 960, 960, 1037, 1037,
  960, 1062, 1039, 1061, 1043, 960, 960, 960, 960, 1037, 1063, 1062, 1039, 1043, 960, 960, 1037,
  1039, 1064, 960, 960, 1037, 1065, 1064, 1065, 0, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,

  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960, 960, 960, 960, 960, 960 };

static const flex_int16_t yy_nxt[2837] = { 0, 4, 5, 6, 7, 7, 5, 8, 9, 4, 10, 11, 12, 13, 14, 15, 16,
  14, 17, 18, 19, 20, 21, 21, 21, 21, 21, 21, 21, 22, 23, 24, 25, 4, 26, 27, 28, 27, 27, 27, 27, 27,
  27, 27, 27, 29, 27, 27, 27, 27, 30, 31, 27, 27, 32, 33, 27, 27, 34, 35, 36, 37, 38, 39, 40, 41,
  42, 43, 44, 27, 27, 45, 27, 46, 47, 48, 49, 50, 27, 51, 52, 53, 54, 55, 56, 57, 27, 27, 14, 58,
  14, 27, 59, 60, 65, 61, 59, 68, 65, 62, 70,

  73, 71, 72, 77, 77, 88, 77, 77, 86, 63, 94, 108, 78, 914, 109, 95, 79, 123, 89, 90, 74, 91, 64,
  87, 110, 92, 96, 93, 93, 93, 93, 93, 93, 93, 93, 80, 124, 82, 120, 104, 115, 116, 121, 111, 112,
  113, 98, 69, 105, 105, 105, 105, 105, 105, 105, 105, 83, 120, 129, 960, 130, 121, 150, 84, 97,
  107, 127, 127, 75, 127, 127, 98, 151, 99, 99, 99, 99, 99, 99, 99, 100, 122, 132, 138, 141, 139,
  143, 101, 133, 142, 102, 184, 140, 144, 107, 134, 145, 135, 147, 146,

  122, 136, 162, 152, 163, 164, 154, 148, 103, 153, 137, 155, 165, 68, 158, 166, 101, 149, 159, 102,
  168, 169, 128, 172, 120, 198, 173, 160, 121, 179, 170, 171, 915, 161, 180, 174, 193, 103, 200,
  181, 200, 194, 175, 176, 186, 187, 65, 187, 186, 185, 65, 188, 96, 203, 200, 211, 77, 77, 201, 77,
  77, 200, 189, 211, 69, 78, 202, 122, 207, 79, 220, 220, 76, 213, 285, 190, 286, 208, 208, 208,
  208, 208, 208, 208, 208, 68, 213, 204, 80, 916, 82, 177, 257, 258, 210, 200, 178, 99, 99, 99,

  99, 99, 99, 99, 100, 235, 269, 259, 265, 83, 260, 322, 266, 236, 270, 261, 84, 288, 127, 127, 276,
  127, 127, 210, 214, 214, 214, 214, 214, 214, 214, 214, 282, 97, 277, 289, 69, 283, 315, 316, 98,
  216, 99, 99, 99, 99, 99, 99, 99, 100, 366, 219, 291, 200, 302, 292, 303, 367, 98, 218, 100, 100,
  100, 100, 100, 100, 100, 100, 293, 917, 216, 323, 120, 221, 128, 221, 121, 102, 222, 222, 222,
  222, 222, 222, 222, 222, 437, 200, 218, 105, 105, 105, 105, 105, 105, 105, 105, 307, 104, 191,

  321, 309, 308, 377, 438, 98, 102, 105, 105, 105, 105, 105, 105, 105, 105, 122, 378, 78, 318, 191,
  221, 79, 221, 68, 107, 225, 225, 225, 225, 225, 225, 225, 225, 241, 298, 242, 243, 200, 244, 343,
  343, 186, 187, 299, 187, 186, 310, 245, 188, 246, 247, 248, 918, 107, 310, 192, 312, 313, 417,
  189, 208, 208, 208, 208, 208, 208, 208, 208, 342, 418, 313, 420, 190, 324, 69, 192, 325, 343, 343,
  432, 421, 207, 441, 314, 442, 200, 68, 432, 326, 327, 208, 208, 208, 208, 208, 208, 208, 208, 200,
  200,

  200, 447, 530, 329, 448, 329, 531, 210, 330, 330, 330, 330, 330, 330, 330, 330, 333, 100, 100,
  100, 100, 100, 100, 100, 100, 334, 334, 334, 334, 334, 334, 334, 334, 200, 451, 200, 210, 69, 338,
  453, 338, 565, 336, 339, 339, 339, 339, 339, 339, 339, 339, 221, 551, 221, 434, 435, 341, 341,
  341, 341, 341, 341, 341, 341, 500, 554, 501, 555, 435, 200, 552, 336, 222, 222, 222, 222, 222,
  222, 222, 222, 345, 436, 556, 200, 200, 452, 919, 557, 200, 346, 346, 346, 346, 346, 346, 346,
  346, 348, 200, 200,

  200, 564, 200, 744, 566, 200, 349, 349, 349, 349, 349, 349, 349, 349, 446, 810, 345, 200, 200,
  350, 350, 350, 350, 350, 350, 352, 352, 352, 352, 352, 352, 352, 352, 920, 342, 449, 541, 567,
  568, 570, 738, 659, 450, 343, 343, 542, 200, 200, 350, 350, 350, 350, 350, 350, 454, 454, 454,
  454, 454, 454, 454, 454, 455, 334, 334, 334, 334, 334, 334, 334, 334, 456, 456, 456, 456, 456,
  456, 456, 456, 333, 462, 462, 462, 462, 462, 462, 462, 462, 334, 334, 334, 334, 334, 334, 334,
  334, 200, 569, 666, 604,

  200, 460, 921, 460, 605, 336, 461, 461, 461, 461, 461, 461, 461, 461, 463, 346, 346, 346, 346,
  346, 346, 346, 346, 464, 464, 464, 464, 464, 464, 464, 464, 345, 649, 787, 336, 788, 662, 650,
  571, 345, 466, 466, 466, 466, 466, 466, 466, 466, 346, 346, 346, 346, 346, 346, 346, 346, 348,
  572, 572, 572, 572, 572, 572, 572, 572, 349, 349, 349, 349, 349, 349, 349, 349, 705, 705, 345,
  705, 705, 350, 350, 350, 350, 350, 350, 352, 352, 352, 352, 352, 352, 352, 352, 573, 573, 573,
  573, 573, 573, 573, 573,

  200, 200, 922, 200, 923, 455, 660, 350, 350, 350, 350, 350, 350, 348, 572, 572, 572, 572, 572,
  572, 572, 572, 470, 470, 470, 470, 470, 470, 470, 470, 200, 809, 455, 924, 746, 471, 471, 471,
  471, 471, 471, 456, 456, 456, 456, 456, 456, 456, 456, 577, 577, 577, 577, 577, 577, 577, 577,
  925, 926, 927, 928, 574, 200, 200, 471, 471, 471, 471, 471, 471, 575, 575, 575, 575, 575, 575,
  575, 575, 463, 929, 778, 778, 664, 778, 778, 930, 463, 577, 577, 577, 577, 577, 577, 577, 577,
  464, 464, 464, 464, 464,

  464, 464, 464, 345, 200, 200, 743, 813, 200, 933, 200, 200, 466, 466, 466, 466, 466, 466, 466,
  466, 348, 661, 200, 783, 783, 934, 783, 783, 716, 470, 470, 470, 470, 470, 470, 470, 470, 717,
  718, 935, 663, 665, 471, 471, 471, 471, 471, 471, 633, 455, 784, 936, 634, 635, 815, 743, 814,
  636, 572, 572, 572, 572, 572, 572, 572, 572, 937, 939, 940, 574, 943, 471, 471, 471, 471, 471,
  471, 348, 667, 667, 667, 667, 667, 667, 667, 667, 470, 470, 470, 470, 470, 470, 470, 470, 783,
  783, 944, 783, 783, 471,

  471, 471, 471, 471, 471, 667, 667, 667, 667, 667, 667, 667, 667, 200, 200, 200, 945, 947, 948,
  949, 739, 784, 950, 705, 705, 574, 705, 705, 471, 471, 471, 471, 471, 471, 575, 575, 575, 575,
  575, 575, 575, 575, 463, 862, 862, 951, 862, 862, 952, 816, 745, 577, 577, 577, 577, 577, 577,
  577, 577, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709,
  709, 709, 709, 710, 710, 710, 710, 710, 710, 710, 710, 709, 709, 709, 709, 709, 200, 740, 740,
  200, 740, 740, 574, 200,

  200, 780, 953, 882, 956, 957, 741, 667, 667, 667, 667, 667, 667, 667, 667, 913, 709, 709, 709,
  709, 200, 740, 740, 912, 740, 740, 778, 778, 747, 778, 778, 911, 811, 811, 741, 811, 811, 910,
  909, 851, 742, 908, 200, 743, 852, 812, 709, 709, 709, 710, 719, 719, 719, 719, 719, 719, 719,
  719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 720, 720, 720, 720, 720, 720,
  720, 720, 719, 719, 719, 719, 719, 200, 811, 811, 743, 811, 811, 740, 740, 907, 740, 740, 906,
  931, 931, 812, 931, 931,

  905, 904, 741, 903, 829, 902, 900, 719, 719, 719, 719, 200, 899, 898, 862, 862, 200, 862, 862,
  897, 896, 895, 932, 894, 893, 892, 891, 743, 890, 889, 887, 886, 885, 884, 883, 882, 742, 719,
  719, 719, 720, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770, 770,
  770, 770, 770, 770, 771, 771, 771, 771, 771, 771, 771, 771, 770, 770, 770, 770, 770, 881, 740,
  740, 880, 740, 740, 941, 941, 879, 941, 941, 877, 931, 931, 741, 931, 931, 876, 888, 941, 941,
  875, 941, 941, 770, 770,

  770, 770, 200, 874, 873, 872, 871, 942, 870, 869, 868, 867, 866, 932, 865, 864, 863, 861, 858,
  857, 942, 679, 742, 856, 679, 855, 854, 853, 770, 770, 770, 771, 776, 776, 776, 776, 776, 776,
  776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 777, 777, 777, 777, 777,
  777, 777, 777, 776, 776, 776, 776, 776, 850, 954, 954, 849, 954, 954, 954, 954, 848, 954, 954,
  847, 846, 845, 844, 843, 842, 841, 840, 839, 838, 837, 836, 835, 776, 776, 776, 776, 955, 834,
  833, 832, 831, 955, 830,

  828, 827, 826, 825, 824, 823, 679, 822, 821, 820, 679, 819, 818, 817, 671, 671, 200, 808, 807,
  776, 776, 776, 777, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785,
  785, 785, 785, 785, 785, 786, 786, 786, 786, 786, 786, 786, 786, 785, 785, 785, 785, 785, 806,
  805, 804, 803, 802, 801, 800, 799, 798, 797, 796, 795, 794, 793, 792, 791, 790, 789, 782, 781,
  779, 775, 774, 773, 785, 785, 785, 785, 772, 769, 768, 767, 766, 765, 764, 763, 762, 761, 760,
  759, 758, 757, 756, 755,

  754, 753, 752, 751, 750, 749, 748, 737, 736, 735, 785, 785, 785, 786, 859, 859, 859, 859, 859,
  859, 859, 859, 859, 859, 859, 859, 859, 859, 859, 859, 859, 859, 859, 859, 860, 860, 860, 860,
  860, 860, 860, 860, 859, 859, 859, 859, 859, 734, 733, 732, 731, 730, 729, 728, 727, 726, 725,
  724, 723, 722, 721, 715, 714, 713, 712, 711, 708, 707, 706, 704, 703, 859, 859, 859, 859, 702,
  701, 700, 699, 698, 697, 696, 695, 694, 693, 692, 691, 690, 689, 688, 687, 686, 685, 684, 683,
  682, 681, 680, 679, 678,

  677, 859, 859, 859, 860, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 75, 75, 75, 75,
  75, 75, 676, 75, 75, 75, 75, 75, 75, 75, 81, 81, 675, 81, 81, 674, 673, 672, 671, 670, 81, 81, 81,
  106, 106, 106, 106, 669, 106, 106, 106, 117, 117, 668, 117, 117, 117, 191, 191, 658, 191, 191,
  191, 191, 191, 191, 191, 191, 191, 191, 191, 196, 196, 196, 199, 199, 199, 199, 199, 199, 209,
  657, 209, 209, 656, 209, 209, 209, 212, 212, 655, 212, 212, 212, 212, 212, 212,

  212, 212, 212, 212, 212, 215, 215, 654, 215, 215, 215, 217, 217, 217, 217, 651, 217, 217, 217,
  223, 223, 648, 223, 224, 224, 647, 224, 224, 224, 232, 646, 645, 644, 232, 232, 232, 232, 232,
  232, 232, 232, 232, 232, 311, 311, 643, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311,
  317, 317, 642, 317, 317, 317, 319, 319, 319, 328, 328, 641, 328, 328, 328, 335, 640, 335, 335,
  639, 335, 335, 335, 337, 337, 638, 337, 337, 337, 340, 340, 637, 340, 340, 340, 344, 632, 344,
  631, 630, 344, 344, 344,

  347, 629, 347, 347, 628, 347, 347, 347, 351, 627, 351, 351, 626, 351, 351, 351, 353, 625, 353,
  353, 624, 353, 353, 353, 433, 433, 623, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433,
  439, 439, 622, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 445, 445, 621, 445, 445,
  445, 81, 620, 619, 618, 617, 616, 81, 81, 81, 199, 199, 199, 199, 199, 199, 457, 615, 457, 457,
  614, 457, 457, 457, 458, 458, 613, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 458, 335,
  612, 335, 335, 611,

  335, 335, 335, 459, 459, 610, 459, 459, 459, 337, 337, 609, 337, 337, 337, 465, 608, 465, 465,
  607, 465, 465, 465, 340, 340, 606, 340, 340, 340, 467, 603, 467, 467, 602, 467, 467, 467, 344,
  601, 344, 600, 599, 344, 344, 344, 468, 468, 598, 468, 468, 468, 347, 597, 347, 347, 596, 347,
  347, 347, 469, 469, 595, 469, 469, 469, 349, 349, 594, 349, 351, 593, 351, 351, 592, 351, 351,
  351, 472, 591, 472, 472, 590, 472, 472, 472, 473, 473, 589, 473, 473, 473, 353, 588, 353, 353,
  587, 353, 353, 353, 474,

  474, 586, 474, 474, 474, 117, 117, 585, 117, 117, 117, 478, 478, 478, 433, 433, 584, 433, 433,
  433, 433, 433, 433, 433, 433, 433, 433, 433, 553, 553, 583, 553, 553, 553, 553, 553, 553, 553,
  553, 553, 553, 553, 311, 311, 581, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 439,
  439, 580, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 439, 559, 559, 579, 559, 559, 559,
  559, 559, 559, 559, 559, 559, 559, 559, 560, 560, 563, 560, 560, 560, 560, 560, 560, 560, 560,
  560, 560, 560, 561, 561,

  562, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 561, 445, 445, 558, 445, 445, 445, 199,
  199, 199, 199, 199, 199, 209, 550, 209, 209, 549, 209, 209, 209, 457, 548, 457, 457, 547, 457,
  457, 457, 328, 328, 546, 328, 328, 328, 458, 458, 545, 458, 458, 458, 458, 458, 458, 458, 458,
  458, 458, 458, 459, 459, 544, 459, 459, 459, 576, 543, 576, 576, 540, 576, 576, 576, 215, 539,
  215, 215, 538, 215, 215, 215, 465, 537, 465, 465, 536, 465, 465, 465, 337, 337, 535, 337, 337,
  337, 467, 534, 467, 467,

  533, 467, 467, 467, 578, 578, 532, 578, 578, 578, 468, 468, 529, 468, 468, 468, 469, 469, 528,
  469, 469, 469, 472, 527, 472, 472, 526, 472, 472, 472, 473, 473, 525, 473, 473, 473, 474, 474,
  524, 474, 474, 474, 117, 117, 523, 117, 117, 117, 582, 582, 522, 582, 582, 582, 433, 433, 521,
  433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 433, 553, 553, 520, 553, 553, 553, 553, 553,
  553, 553, 553, 553, 553, 553, 652, 652, 519, 652, 652, 652, 652, 652, 652, 652, 652, 652, 652,
  652, 653, 653, 518, 653,

  653, 653, 653, 653, 653, 653, 653, 653, 653, 653, 311, 311, 517, 311, 311, 311, 311, 311, 311,
  311, 311, 311, 311, 311, 559, 559, 516, 559, 559, 559, 559, 559, 559, 559, 559, 559, 559, 559,
  560, 560, 515, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 560, 561, 561, 514, 561, 561,
  561, 561, 561, 561, 561, 561, 561, 561, 561, 199, 199, 199, 199, 199, 199, 209, 513, 209, 209,
  512, 209, 209, 209, 335, 511, 335, 335, 510, 335, 335, 335, 576, 509, 576, 576, 508, 576, 576,
  576, 459, 459, 507, 459,

  459, 459, 215, 506, 215, 215, 505, 215, 215, 215, 578, 578, 504, 578, 578, 578, 878, 878, 503,
  878, 878, 878, 878, 878, 878, 878, 878, 878, 878, 878, 901, 901, 502, 901, 901, 901, 901, 901,
  901, 901, 901, 901, 901, 901, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 709, 499, 498,
  709, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 497, 496, 719, 770, 770, 770, 770,
  770, 770, 770, 770, 770, 770, 770, 495, 494, 770, 776, 776, 776, 776, 776, 776, 776, 776, 776,
  776, 776, 493, 492, 776,

  785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 785, 491, 490, 785, 938, 938, 489, 938, 938,
  938, 938, 938, 938, 938, 938, 938, 938, 938, 946, 946, 488, 946, 946, 946, 946, 946, 946, 946,
  946, 946, 946, 946, 859, 859, 859, 859, 859, 859, 859, 859, 859, 859, 859, 487, 486, 859, 958,
  958, 485, 958, 958, 958, 958, 958, 958, 958, 958, 958, 958, 958, 959, 959, 484, 959, 959, 959,
  959, 959, 959, 959, 959, 959, 959, 959, 483, 482, 481, 480, 479, 477, 476, 475, 444, 443, 440,
  331, 431, 430, 429, 428,

  427, 426, 425, 424, 423, 422, 419, 416, 415, 414, 413, 412, 411, 410, 409, 408, 407, 406, 405,
  404, 403, 402, 401, 400, 399, 398, 397, 396, 395, 394, 393, 392, 391, 390, 389, 388, 387, 386,
  385, 384, 383, 382, 381, 380, 379, 376, 375, 374, 373, 372, 371, 370, 369, 368, 365, 364, 363,
  362, 361, 360, 359, 358, 233, 357, 356, 355, 354, 332, 331, 320, 200, 192, 195, 192, 306, 305,
  304, 301, 300, 297, 296, 295, 294, 290, 287, 284, 281, 280, 279, 278, 275, 274, 273, 272, 271,
  268, 267, 264, 263, 262,

  256, 255, 254, 253, 252, 251, 250, 249, 240, 239, 238, 237, 129, 234, 233, 231, 230, 125, 76, 229,
  228, 227, 226, 206, 205, 200, 197, 195, 192, 183, 182, 167, 157, 156, 131, 126, 125, 119, 118,
  114, 85, 76, 66, 960, 3, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960,

  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960 };

static const flex_int16_t yy_chk[2837] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 2, 2, 5, 2, 2, 9, 5, 2, 10,

  11, 10, 10, 13, 13, 17, 13, 13, 16, 2, 19, 22, 13, 890, 22, 19, 13, 30, 17, 17, 11, 18, 2, 16, 23,
  18, 19, 18, 18, 18, 18, 18, 18, 18, 18, 13, 30, 13, 29, 21, 25, 25, 29, 23, 23, 23, 21, 9, 21, 21,
  21, 21, 21, 21, 21, 21, 13, 32, 35, 76, 35, 32, 43, 13, 20, 21, 34, 34, 76, 34, 34, 20, 43, 20,
  20, 20, 20, 20, 20, 20, 20, 29, 38, 39, 40, 39, 41, 20, 38, 40, 20, 58, 39, 41, 21, 38, 41, 38,
  42, 41,

  32, 38, 49, 44, 49, 49, 45, 42, 20, 44, 38, 45, 50, 67, 48, 50, 20, 42, 48, 20, 52, 52, 34, 53,
  54, 75, 53, 48, 54, 55, 52, 52, 891, 48, 55, 53, 63, 20, 80, 55, 83, 63, 53, 54, 59, 59, 65, 59,
  59, 58, 65, 59, 63, 83, 84, 94, 77, 77, 80, 77, 77, 82, 59, 94, 67, 77, 82, 54, 93, 77, 101, 101,
  75, 95, 167, 59, 167, 93, 93, 93, 93, 93, 93, 93, 93, 120, 95, 84, 77, 893, 77, 54, 146, 146, 93,
  202, 54, 97, 97, 97,

  97, 97, 97, 97, 97, 132, 154, 147, 151, 77, 147, 202, 151, 132, 154, 147, 77, 169, 127, 127, 160,
  127, 127, 93, 98, 98, 98, 98, 98, 98, 98, 98, 165, 99, 160, 169, 120, 165, 195, 195, 99, 98, 99,
  99, 99, 99, 99, 99, 99, 99, 242, 100, 171, 203, 180, 171, 180, 242, 100, 99, 100, 100, 100, 100,
  100, 100, 100, 100, 171, 894, 98, 203, 176, 102, 127, 102, 176, 100, 102, 102, 102, 102, 102, 102,
  102, 102, 312, 201, 99, 104, 104, 104, 104, 104, 104, 104, 104, 189, 105, 192,

  201, 192, 189, 252, 312, 105, 100, 105, 105, 105, 105, 105, 105, 105, 105, 176, 252, 320, 197,
  309, 107, 320, 107, 197, 105, 107, 107, 107, 107, 107, 107, 107, 107, 137, 177, 137, 137, 204,
  137, 342, 342, 186, 186, 177, 186, 186, 193, 137, 186, 137, 137, 137, 895, 105, 193, 192, 194,
  194, 293, 186, 207, 207, 207, 207, 207, 207, 207, 207, 220, 293, 194, 295, 186, 204, 197, 309,
  204, 220, 220, 307, 295, 208, 314, 194, 314, 322, 318, 307, 204, 204, 208, 208, 208, 208, 208,
  208, 208, 208, 327, 323,

  325, 322, 412, 210, 323, 210, 412, 208, 210, 210, 210, 210, 210, 210, 210, 210, 214, 219, 219,
  219, 219, 219, 219, 219, 219, 214, 214, 214, 214, 214, 214, 214, 214, 326, 325, 447, 208, 318,
  216, 327, 216, 447, 214, 216, 216, 216, 216, 216, 216, 216, 216, 218, 434, 218, 308, 308, 218,
  218, 218, 218, 218, 218, 218, 218, 381, 436, 381, 436, 308, 663, 434, 214, 221, 221, 221, 221,
  221, 221, 221, 221, 222, 308, 437, 446, 448, 326, 897, 437, 450, 222, 222, 222, 222, 222, 222,
  222, 222, 223, 324, 449,

  739, 446, 452, 663, 448, 321, 223, 223, 223, 223, 223, 223, 223, 223, 321, 739, 225, 564, 659,
  223, 223, 223, 223, 223, 223, 225, 225, 225, 225, 225, 225, 225, 225, 899, 343, 324, 422, 449,
  450, 452, 659, 564, 324, 343, 343, 422, 451, 571, 223, 223, 223, 223, 223, 223, 329, 329, 329,
  329, 329, 329, 329, 329, 330, 333, 333, 333, 333, 333, 333, 333, 333, 330, 330, 330, 330, 330,
  330, 330, 330, 334, 338, 338, 338, 338, 338, 338, 338, 338, 334, 334, 334, 334, 334, 334, 334,
  334, 453, 451, 571, 504,

  567, 336, 900, 336, 504, 334, 336, 336, 336, 336, 336, 336, 336, 336, 339, 345, 345, 345, 345,
  345, 345, 345, 345, 339, 339, 339, 339, 339, 339, 339, 339, 341, 551, 712, 334, 712, 567, 551,
  453, 346, 341, 341, 341, 341, 341, 341, 341, 341, 346, 346, 346, 346, 346, 346, 346, 346, 349,
  455, 455, 455, 455, 455, 455, 455, 455, 349, 349, 349, 349, 349, 349, 349, 349, 625, 625, 352,
  625, 625, 349, 349, 349, 349, 349, 349, 352, 352, 352, 352, 352, 352, 352, 352, 460, 460, 460,
  460, 460, 460, 460, 460,

  665, 565, 902, 738, 903, 454, 565, 349, 349, 349, 349, 349, 349, 350, 454, 454, 454, 454, 454,
  454, 454, 454, 350, 350, 350, 350, 350, 350, 350, 350, 569, 738, 456, 904, 665, 350, 350, 350,
  350, 350, 350, 456, 456, 456, 456, 456, 456, 456, 456, 463, 463, 463, 463, 463, 463, 463, 463,
  905, 906, 907, 908, 461, 662, 744, 350, 350, 350, 350, 350, 350, 461, 461, 461, 461, 461, 461,
  461, 461, 462, 911, 703, 703, 569, 703, 703, 912, 464, 462, 462, 462, 462, 462, 462, 462, 462,
  464, 464, 464, 464, 464,

  464, 464, 464, 466, 568, 570, 662, 744, 566, 914, 746, 813, 466, 466, 466, 466, 466, 466, 466,
  466, 470, 566, 745, 708, 708, 915, 708, 708, 636, 470, 470, 470, 470, 470, 470, 470, 470, 636,
  636, 917, 568, 570, 470, 470, 470, 470, 470, 470, 535, 572, 708, 922, 535, 535, 746, 813, 745,
  535, 572, 572, 572, 572, 572, 572, 572, 572, 923, 925, 926, 573, 930, 470, 470, 470, 470, 470,
  470, 471, 573, 573, 573, 573, 573, 573, 573, 573, 471, 471, 471, 471, 471, 471, 471, 471, 783,
  783, 933, 783, 783, 471,

  471, 471, 471, 471, 471, 574, 574, 574, 574, 574, 574, 574, 574, 660, 664, 747, 935, 937, 939,
  940, 660, 783, 943, 705, 705, 575, 705, 705, 471, 471, 471, 471, 471, 471, 575, 575, 575, 575,
  575, 575, 575, 575, 577, 830, 830, 944, 830, 830, 947, 747, 664, 577, 577, 577, 577, 577, 577,
  577, 577, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630,
  630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 630, 666, 661, 661,
  814, 661, 661, 667, 815,

  816, 705, 948, 949, 951, 952, 661, 667, 667, 667, 667, 667, 667, 667, 667, 889, 630, 630, 630,
  630, 661, 740, 740, 888, 740, 740, 778, 778, 666, 778, 778, 887, 811, 811, 740, 811, 811, 886,
  885, 814, 661, 884, 851, 815, 816, 811, 630, 630, 630, 630, 637, 637, 637, 637, 637, 637, 637,
  637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637, 637,
  637, 637, 637, 637, 637, 637, 637, 852, 743, 743, 851, 743, 743, 809, 809, 883, 809, 809, 881,
  913, 913, 743, 913, 913,

  880, 879, 809, 877, 778, 876, 874, 637, 637, 637, 637, 743, 873, 872, 862, 862, 809, 862, 862,
  871, 870, 869, 913, 868, 867, 866, 865, 852, 864, 863, 861, 858, 856, 854, 853, 850, 809, 637,
  637, 637, 637, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696,
  696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 849, 810,
  810, 848, 810, 810, 929, 929, 847, 929, 929, 845, 931, 931, 810, 931, 931, 844, 862, 941, 941,
  843, 941, 941, 696, 696,

  696, 696, 810, 842, 841, 840, 839, 929, 838, 837, 836, 835, 834, 931, 833, 832, 831, 829, 826,
  824, 941, 823, 810, 822, 821, 820, 819, 818, 696, 696, 696, 696, 702, 702, 702, 702, 702, 702,
  702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
  702, 702, 702, 702, 702, 702, 702, 702, 808, 950, 950, 807, 950, 950, 954, 954, 806, 954, 954,
  805, 804, 803, 802, 801, 800, 796, 794, 793, 792, 791, 790, 789, 702, 702, 702, 702, 950, 788,
  787, 782, 780, 954, 779,

  774, 772, 768, 766, 765, 762, 761, 760, 758, 757, 756, 755, 754, 753, 749, 748, 742, 737, 736,
  702, 702, 702, 702, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711,
  711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 711, 735,
  734, 733, 732, 731, 730, 728, 727, 725, 724, 722, 721, 718, 717, 716, 715, 714, 713, 707, 706,
  704, 701, 700, 699, 711, 711, 711, 711, 698, 695, 694, 692, 691, 690, 689, 688, 686, 685, 684,
  683, 682, 681, 680, 678,

  677, 675, 674, 672, 670, 669, 668, 658, 657, 656, 711, 711, 711, 711, 828, 828, 828, 828, 828,
  828, 828, 828, 828, 828, 828, 828, 828, 828, 828, 828, 828, 828, 828, 828, 828, 828, 828, 828,
  828, 828, 828, 828, 828, 828, 828, 828, 828, 655, 654, 651, 650, 649, 647, 646, 645, 644, 643,
  642, 641, 640, 639, 635, 634, 633, 632, 631, 628, 627, 626, 624, 623, 828, 828, 828, 828, 622,
  621, 620, 618, 617, 616, 615, 611, 610, 607, 606, 605, 604, 603, 602, 599, 598, 597, 596, 595,
  594, 593, 592, 591, 590,

  589, 828, 828, 828, 828, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961,
  962, 962, 962, 962, 962, 962, 588, 962, 962, 962, 962, 962, 962, 962, 963, 963, 587, 963, 963,
  586, 585, 584, 583, 581, 963, 963, 963, 964, 964, 964, 964, 580, 964, 964, 964, 965, 965, 579,
  965, 965, 965, 966, 966, 563, 966, 966, 966, 966, 966, 966, 966, 966, 966, 966, 966, 967, 967,
  967, 968, 968, 968, 968, 968, 968, 969, 562, 969, 969, 558, 969, 969, 969, 970, 970, 557, 970,
  970, 970, 970, 970, 970,

  970, 970, 970, 970, 970, 971, 971, 556, 971, 971, 971, 972, 972, 972, 972, 552, 972, 972, 972,
  973, 973, 550, 973, 974, 974, 549, 974, 974, 974, 975, 548, 547, 546, 975, 975, 975, 975, 975,
  975, 975, 975, 975, 975, 976, 976, 544, 976, 976, 976, 976, 976, 976, 976, 976, 976, 976, 976,
  977, 977, 542, 977, 977, 977, 978, 978, 978, 979, 979, 541, 979, 979, 979, 980, 539, 980, 980,
  538, 980, 980, 980, 981, 981, 537, 981, 981, 981, 982, 982, 536, 982, 982, 982, 983, 534, 983,
  533, 532, 983, 983, 983,

  984, 531, 984, 984, 530, 984, 984, 984, 985, 528, 985, 985, 527, 985, 985, 985, 986, 526, 986,
  986, 525, 986, 986, 986, 987, 987, 524, 987, 987, 987, 987, 987, 987, 987, 987, 987, 987, 987,
  988, 988, 523, 988, 988, 988, 988, 988, 988, 988, 988, 988, 988, 988, 989, 989, 521, 989, 989,
  989, 990, 520, 519, 518, 517, 516, 990, 990, 990, 991, 991, 991, 991, 991, 991, 992, 515, 992,
  992, 514, 992, 992, 992, 993, 993, 513, 993, 993, 993, 993, 993, 993, 993, 993, 993, 993, 993,
  994, 511, 994, 994, 510,

  994, 994, 994, 995, 995, 509, 995, 995, 995, 996, 996, 508, 996, 996, 996, 997, 507, 997, 997,
  506, 997, 997, 997, 998, 998, 505, 998, 998, 998, 999, 501, 999, 999, 500, 999, 999, 999, 1000,
  497, 1000, 496, 495, 1000, 1000, 1000, 1001, 1001, 494, 1001, 1001, 1001, 1002, 493, 1002, 1002,
  492, 1002, 1002, 1002, 1003, 1003, 491, 1003, 1003, 1003, 1004, 1004, 490, 1004, 1005, 489, 1005,
  1005, 488, 1005, 1005, 1005, 1006, 487, 1006, 1006, 486, 1006, 1006, 1006, 1007, 1007, 485, 1007,
  1007, 1007, 1008, 484, 1008, 1008, 483, 1008, 1008, 1008, 1009,

  1009, 482, 1009, 1009, 1009, 1010, 1010, 481, 1010, 1010, 1010, 1011, 1011, 1011, 1012, 1012, 480,
  1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1013, 1013, 479, 1013, 1013,
  1013, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1013, 1014, 1014, 477, 1014, 1014, 1014, 1014,
  1014, 1014, 1014, 1014, 1014, 1014, 1014, 1015, 1015, 476, 1015, 1015, 1015, 1015, 1015, 1015,
  1015, 1015, 1015, 1015, 1015, 1016, 1016, 475, 1016, 1016, 1016, 1016, 1016, 1016, 1016, 1016,
  1016, 1016, 1016, 1017, 1017, 444, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017,
  1017, 1018, 1018,

  443, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1018, 1019, 1019, 438, 1019,
  1019, 1019, 1020, 1020, 1020, 1020, 1020, 1020, 1021, 431, 1021, 1021, 430, 1021, 1021, 1021,
  1022, 429, 1022, 1022, 428, 1022, 1022, 1022, 1023, 1023, 426, 1023, 1023, 1023, 1024, 1024, 425,
  1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1025, 1025, 424, 1025, 1025,
  1025, 1026, 423, 1026, 1026, 421, 1026, 1026, 1026, 1027, 420, 1027, 1027, 419, 1027, 1027, 1027,
  1028, 418, 1028, 1028, 417, 1028, 1028, 1028, 1029, 1029, 416, 1029, 1029, 1029, 1030, 415, 1030,
  1030,

  414, 1030, 1030, 1030, 1031, 1031, 413, 1031, 1031, 1031, 1032, 1032, 411, 1032, 1032, 1032, 1033,
  1033, 410, 1033, 1033, 1033, 1034, 409, 1034, 1034, 408, 1034, 1034, 1034, 1035, 1035, 407, 1035,
  1035, 1035, 1036, 1036, 406, 1036, 1036, 1036, 1037, 1037, 405, 1037, 1037, 1037, 1038, 1038, 404,
  1038, 1038, 1038, 1039, 1039, 403, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
  1039, 1040, 1040, 402, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1041,
  1041, 401, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1041, 1042, 1042, 400,
  1042,

  1042, 1042, 1042, 1042, 1042, 1042, 1042, 1042, 1042, 1042, 1043, 1043, 399, 1043, 1043, 1043,
  1043, 1043, 1043, 1043, 1043, 1043, 1043, 1043, 1044, 1044, 398, 1044, 1044, 1044, 1044, 1044,
  1044, 1044, 1044, 1044, 1044, 1044, 1045, 1045, 396, 1045, 1045, 1045, 1045, 1045, 1045, 1045,
  1045, 1045, 1045, 1045, 1046, 1046, 395, 1046, 1046, 1046, 1046, 1046, 1046, 1046, 1046, 1046,
  1046, 1046, 1047, 1047, 1047, 1047, 1047, 1047, 1048, 394, 1048, 1048, 393, 1048, 1048, 1048,
  1049, 392, 1049, 1049, 391, 1049, 1049, 1049, 1050, 389, 1050, 1050, 388, 1050, 1050, 1050, 1051,
  1051, 387, 1051,

  1051, 1051, 1052, 386, 1052, 1052, 385, 1052, 1052, 1052, 1053, 1053, 384, 1053, 1053, 1053, 1054,
  1054, 383, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1054, 1055, 1055, 382,
  1055, 1055, 1055, 1055, 1055, 1055, 1055, 1055, 1055, 1055, 1055, 1056, 1056, 1056, 1056, 1056,
  1056, 1056, 1056, 1056, 1056, 1056, 380, 378, 1056, 1057, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1057, 377, 375, 1057, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058, 1058,
  1058, 1058, 374, 373, 1058, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 372,
  371, 1059,

  1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 370, 369, 1060, 1061, 1061, 368,
  1061, 1061, 1061, 1061, 1061, 1061, 1061, 1061, 1061, 1061, 1061, 1062, 1062, 367, 1062, 1062,
  1062, 1062, 1062, 1062, 1062, 1062, 1062, 1062, 1062, 1063, 1063, 1063, 1063, 1063, 1063, 1063,
  1063, 1063, 1063, 1063, 366, 365, 1063, 1064, 1064, 364, 1064, 1064, 1064, 1064, 1064, 1064, 1064,
  1064, 1064, 1064, 1064, 1065, 1065, 363, 1065, 1065, 1065, 1065, 1065, 1065, 1065, 1065, 1065,
  1065, 1065, 362, 361, 360, 359, 358, 356, 355, 354, 316, 315, 313, 310, 306, 305, 304, 303,

  302, 301, 300, 299, 298, 297, 294, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281,
  280, 279, 278, 277, 276, 274, 273, 272, 271, 269, 268, 267, 266, 265, 264, 263, 262, 261, 260,
  259, 258, 257, 256, 255, 254, 253, 251, 250, 249, 248, 247, 246, 245, 244, 243, 241, 240, 239,
  238, 237, 236, 235, 234, 232, 231, 230, 229, 228, 213, 211, 200, 199, 191, 190, 188, 183, 182,
  181, 179, 178, 175, 174, 173, 172, 170, 168, 166, 164, 163, 162, 161, 159, 158, 157, 156, 155,
  153, 152, 150, 149, 148,

  145, 144, 143, 142, 141, 140, 139, 138, 136, 135, 134, 133, 130, 126, 125, 124, 123, 122, 121,
  119, 118, 116, 112, 92, 90, 81, 69, 64, 62, 57, 56, 51, 47, 46, 37, 33, 31, 28, 26, 24, 15, 12, 8,
  3, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,

  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960,
  960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960, 960 };

/* Table of booleans, true if rule could match eol. */
static const flex_int32_t yy_rule_can_match_eol[166] = {
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
};

static yy_state_type yy_last_accepting_state;
static char* yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char* yytext;

/*

This file must be translated to C and modified to build everywhere.

See the adjacent README.txt file for instructions.

*/

/* to workaround https://bugs.llvm.org/show_bug.cgi?id=43465 */
#if defined(__clang__)
#pragma clang diagnostic push
#if defined(__has_warning)
#if __has_warning("-Wimplicit-fallthrough")
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#endif
#endif
#elif defined(__GNUC__) && (__GNUC__ >= 7)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
#endif

/* We do not care of interactive mode */
#define YY_NEVER_INTERACTIVE 1

/* Do not include unistd.h in generated source. */
#define YY_NO_UNISTD_H

/* Skip declaring this function.  It is a macro.  */
#define YY_SKIP_YYWRAP

#ifdef _WIN32
#pragma warning(disable : 4018)
#pragma warning(disable : 4127)
#pragma warning(disable : 4131)
#pragma warning(disable : 4244)
#pragma warning(disable : 4251)
#pragma warning(disable : 4267)
#pragma warning(disable : 4305)
#pragma warning(disable : 4309)
#pragma warning(disable : 4706)
#pragma warning(disable : 4786)
#endif

#define SKIP_MATCH_MAXLEN 15

/*
 * Skip ahead until one of the strings is found,
 * then skip to the end of the line.
 * Return 0 if no match found.
 */
static int skip_comment(void);
static int skip_trailing_comment(const char* text, size_t l);
static int skip_ahead_multi(const char* strings[]);
static int skip_ahead_until(const char* text);
static int skip_to_next_directive(void);
static int skip_conditional_block(void);

static void doxygen_comment(void);
static void doxygen_cpp_comment(void);
static void doxygen_group_start(void);
static void doxygen_group_end(void);
static void vtk_comment(void);
static void vtk_name_comment(void);
static void vtk_section_comment(void);
static void cpp_comment_line(void);
static void blank_line(void);

static const char* raw_string(const char* begin, int* has_ud_suffix);

static void preprocessor_directive(const char* text, size_t l);
static void print_preprocessor_error(int result, const char* cp, size_t n);
static char* get_macro_arguments(void);
static void skip_macro_arguments(void);

static void push_buffer(void);
static int pop_buffer(void);

static void push_include(const char* filename);
static void pop_include(void);

static void push_macro(MacroInfo* macro);
static void pop_macro(void);
static int in_macro(void);

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void*
#endif

static int yy_init_globals(void);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy(void);

int yyget_debug(void);

void yyset_debug(int debug_flag);

YY_EXTRA_TYPE yyget_extra(void);

void yyset_extra(YY_EXTRA_TYPE user_defined);

FILE* yyget_in(void);

void yyset_in(FILE* _in_str);

FILE* yyget_out(void);

void yyset_out(FILE* _out_str);

int yyget_leng(void);

char* yyget_text(void);

int yyget_lineno(void);

void yyset_lineno(int _line_number);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap(void);
#else
extern int yywrap(void);
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput(int c, char* buf_ptr);

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy(char*, const char*, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char*);
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void);
#else
static int input(void);
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO                                                                                       \
  do                                                                                               \
  {                                                                                                \
    if (fwrite(yytext, (size_t)yyleng, 1, yyout))                                                  \
    {                                                                                              \
    }                                                                                              \
  } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                                            \
  if (YY_CURRENT_BUFFER_LVALUE->yy_is_interactive)                                                 \
  {                                                                                                \
    int c = '*';                                                                                   \
    int n;                                                                                         \
    for (n = 0; n < max_size && (c = getc(yyin)) != EOF && c != '\n'; ++n)                         \
      buf[n] = (char)c;                                                                            \
    if (c == '\n')                                                                                 \
      buf[n++] = (char)c;                                                                          \
    if (c == EOF && ferror(yyin))                                                                  \
      YY_FATAL_ERROR("input in flex scanner failed");                                              \
    result = n;                                                                                    \
  }                                                                                                \
  else                                                                                             \
  {                                                                                                \
    errno = 0;                                                                                     \
    while ((result = (int)fread(buf, 1, (yy_size_t)max_size, yyin)) == 0 && ferror(yyin))          \
    {                                                                                              \
      if (errno != EINTR)                                                                          \
      {                                                                                            \
        YY_FATAL_ERROR("input in flex scanner failed");                                            \
        break;                                                                                     \
      }                                                                                            \
      errno = 0;                                                                                   \
      clearerr(yyin);                                                                              \
    }                                                                                              \
  }

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex(void);

#define YY_DECL int yylex(void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/ break;
#endif

#define YY_RULE_SETUP                                                                              \
  if (yyleng > 0)                                                                                  \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (yytext[yyleng - 1] == '\n');                            \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;

  if (!(yy_init))
  {
    (yy_init) = 1;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if (!(yy_start))
      (yy_start) = 1; /* first start state */

    if (!yyin)
      yyin = stdin;

    if (!yyout)
      yyout = stdout;

    if (!YY_CURRENT_BUFFER)
    {
      yyensure_buffer_stack();
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
    }

    yy_load_buffer_state();
  }

  {

    while (/*CONSTCOND*/ 1) /* loops until end-of-file is reached */
    {
      yy_cp = (yy_c_buf_p);

      /* Support of yytext. */
      *yy_cp = (yy_hold_char);

      /* yy_bp points to the position in yy_ch_buf of the start of
       * the current run.
       */
      yy_bp = yy_cp;

      yy_current_state = (yy_start);
      yy_current_state += YY_AT_BOL();
    yy_match:
      do
      {
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
        if (yy_accept[yy_current_state])
        {
          (yy_last_accepting_state) = yy_current_state;
          (yy_last_accepting_cpos) = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
        {
          yy_current_state = (int)yy_def[yy_current_state];
          if (yy_current_state >= 961)
            yy_c = yy_meta[yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        ++yy_cp;
      } while (yy_base[yy_current_state] != 2745);

    yy_find_action:
      yy_act = yy_accept[yy_current_state];
      if (yy_act == 0)
      { /* have to back up */
        yy_cp = (yy_last_accepting_cpos);
        yy_current_state = (yy_last_accepting_state);
        yy_act = yy_accept[yy_current_state];
      }

      YY_DO_BEFORE_ACTION;

      if (yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act])
      {
        int yyl;
        for (yyl = 0; yyl < yyleng; ++yyl)
          if (yytext[yyl] == '\n')

            yylineno++;
        ;
      }

    do_action: /* This label is used only to access EOF actions. */

      switch (yy_act)
      {         /* beginning of action switch */
        case 0: /* must back up */
          /* undo the effects of YY_DO_BEFORE_ACTION */
          *yy_cp = (yy_hold_char);
          yy_cp = (yy_last_accepting_cpos);
          yy_current_state = (yy_last_accepting_state);
          goto yy_find_action;

        case 1:
          YY_RULE_SETUP
          {
            doxygen_comment();
          }
          YY_BREAK
        case 2:
          YY_RULE_SETUP
          {
            doxygen_comment();
          }
          YY_BREAK
        case 3:
          YY_RULE_SETUP
          {
            skip_comment();
          }
          YY_BREAK
        case 4:
          YY_RULE_SETUP
          {
            skip_ahead_until("@end");
          }
          YY_BREAK
        case 5:
          YY_RULE_SETUP
          {
            doxygen_cpp_comment();
          }
          YY_BREAK
        case 6:
          YY_RULE_SETUP
          {
            doxygen_cpp_comment();
          }
          YY_BREAK
        case 7:
          YY_RULE_SETUP
          {
            doxygen_group_start();
          }
          YY_BREAK
        case 8:
          YY_RULE_SETUP
          {
            doxygen_group_end();
          }
          YY_BREAK
        case 9:
          YY_RULE_SETUP
          {
            vtk_comment();
          }
          YY_BREAK
        case 10:
          YY_RULE_SETUP
          {
            vtk_name_comment();
          }
          YY_BREAK
        case 11:
          YY_RULE_SETUP
          {
            vtk_section_comment();
          }
          YY_BREAK
        case 12:
          YY_RULE_SETUP
          {
            cpp_comment_line();
          }
          YY_BREAK
        case 13:
          /* rule 13 can match eol */
          YY_RULE_SETUP
          {
            blank_line();
          }
          YY_BREAK
        case 14:
          YY_RULE_SETUP
          /* eat trailing C++ comments */
          YY_BREAK
        case 15:
          /* rule 15 can match eol */
          YY_RULE_SETUP
          {
            skip_trailing_comment(yytext, yyleng);
            preprocessor_directive(yytext, yyleng);
          }
          YY_BREAK
        case 16:
          /* rule 16 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (STRING_LITERAL);
          }
          YY_BREAK
        case 17:
          /* rule 17 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (STRING_LITERAL_UD);
          }
          YY_BREAK
        case 18:
          /* rule 18 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (CHAR_LITERAL);
          }
          YY_BREAK
        case 19:
          YY_RULE_SETUP
          {
            int has_ud_suffix = 0;
            yylval.str = raw_string(yytext, &has_ud_suffix);
            return (has_ud_suffix ? STRING_LITERAL_UD : STRING_LITERAL);
          }
          YY_BREAK
        case 20:
          YY_RULE_SETUP
          return (AUTO);
          YY_BREAK
        case 21:
          YY_RULE_SETUP
          return (DOUBLE);
          YY_BREAK
        case 22:
          YY_RULE_SETUP
          return (FLOAT);
          YY_BREAK
        case 23:
          YY_RULE_SETUP
          return (SHORT);
          YY_BREAK
        case 24:
          YY_RULE_SETUP
          return (LONG);
          YY_BREAK
        case 25:
          YY_RULE_SETUP
          return (CHAR);
          YY_BREAK
        case 26:
          YY_RULE_SETUP
          return (INT);
          YY_BREAK
        case 27:
          YY_RULE_SETUP
          return (UNSIGNED);
          YY_BREAK
        case 28:
          YY_RULE_SETUP
          return (SIGNED);
          YY_BREAK
        case 29:
          YY_RULE_SETUP
          return (VOID);
          YY_BREAK
        case 30:
          YY_RULE_SETUP
          return (BOOL);
          YY_BREAK
        case 31:
          YY_RULE_SETUP
          return (CHAR16_T);
          YY_BREAK
        case 32:
          YY_RULE_SETUP
          return (CHAR32_T);
          YY_BREAK
        case 33:
          YY_RULE_SETUP
          return (WCHAR_T);
          YY_BREAK
        case 34:
          /* rule 34 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::size_t" : "size_t");
            return (SIZE_T);
          }
          YY_BREAK
        case 35:
          /* rule 35 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::ssize_t" : "ssize_t");
            return (SSIZE_T);
          }
          YY_BREAK
        case 36:
          /* rule 36 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::nullptr_t" : "nullptr_t");
            return (NULLPTR_T);
          }
          YY_BREAK
        case 37:
          YY_RULE_SETUP
          /* ignore the Q_OBJECT macro from Qt */
          YY_BREAK
        case 38:
          /* rule 38 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PUBLIC);
          YY_BREAK
        case 39:
          /* rule 39 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PRIVATE);
          YY_BREAK
        case 40:
          /* rule 40 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 41:
          /* rule 41 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 42:
          YY_RULE_SETUP
          return (CLASS);
          YY_BREAK
        case 43:
          YY_RULE_SETUP
          return (STRUCT);
          YY_BREAK
        case 44:
          YY_RULE_SETUP
          return (PUBLIC);
          YY_BREAK
        case 45:
          YY_RULE_SETUP
          return (PRIVATE);
          YY_BREAK
        case 46:
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 47:
          YY_RULE_SETUP
          return (ENUM);
          YY_BREAK
        case 48:
          YY_RULE_SETUP
          return (UNION);
          YY_BREAK
        case 49:
          YY_RULE_SETUP
          return (VIRTUAL);
          YY_BREAK
        case 50:
          YY_RULE_SETUP
          return (CONST);
          YY_BREAK
        case 51:
          YY_RULE_SETUP
          return (VOLATILE);
          YY_BREAK
        case 52:
          YY_RULE_SETUP
          return (MUTABLE);
          YY_BREAK
        case 53:
          YY_RULE_SETUP
          return (OPERATOR);
          YY_BREAK
        case 54:
          YY_RULE_SETUP
          return (FRIEND);
          YY_BREAK
        case 55:
          YY_RULE_SETUP
          return (INLINE);
          YY_BREAK
        case 56:
          YY_RULE_SETUP
          return (CONSTEXPR);
          YY_BREAK
        case 57:
          YY_RULE_SETUP
          return (STATIC);
          YY_BREAK
        case 58:
          YY_RULE_SETUP
          return (THREAD_LOCAL);
          YY_BREAK
        case 59:
          YY_RULE_SETUP
          return (EXTERN);
          YY_BREAK
        case 60:
          YY_RULE_SETUP
          return (TEMPLATE);
          YY_BREAK
        case 61:
          YY_RULE_SETUP
          return (TYPENAME);
          YY_BREAK
        case 62:
          YY_RULE_SETUP
          return (TYPEDEF);
          YY_BREAK
        case 63:
          YY_RULE_SETUP
          return (NAMESPACE);
          YY_BREAK
        case 64:
          YY_RULE_SETUP
          return (USING);
          YY_BREAK
        case 65:
          YY_RULE_SETUP
          return (NEW);
          YY_BREAK
        case 66:
          YY_RULE_SETUP
          return (DELETE);
          YY_BREAK
        case 67:
          YY_RULE_SETUP
          return (EXPLICIT);
          YY_BREAK
        case 68:
          YY_RULE_SETUP
          return (THROW);
          YY_BREAK
        case 69:
          YY_RULE_SETUP
          return (TRY);
          YY_BREAK
        case 70:
          YY_RULE_SETUP
          return (CATCH);
          YY_BREAK
        case 71:
          YY_RULE_SETUP
          return (NOEXCEPT);
          YY_BREAK
        case 72:
          YY_RULE_SETUP
          return (DECLTYPE);
          YY_BREAK
        case 73:
          YY_RULE_SETUP
          return (DEFAULT);
          YY_BREAK
        case 74:
          YY_RULE_SETUP
          return (STATIC_CAST);
          YY_BREAK
        case 75:
          YY_RULE_SETUP
          return (DYNAMIC_CAST);
          YY_BREAK
        case 76:
          YY_RULE_SETUP
          return (CONST_CAST);
          YY_BREAK
        case 77:
          YY_RULE_SETUP
          return (REINTERPRET_CAST);
          YY_BREAK
        case 78:
          YY_RULE_SETUP
          /* irrelevant to wrappers */
          YY_BREAK
        case 79:
          YY_RULE_SETUP
          return (OP_LOGIC_AND);
          YY_BREAK
        case 80:
          YY_RULE_SETUP
          return (OP_AND_EQ);
          YY_BREAK
        case 81:
          YY_RULE_SETUP
          return (OP_LOGIC_OR);
          YY_BREAK
        case 82:
          YY_RULE_SETUP
          return (OP_OR_EQ);
          YY_BREAK
        case 83:
          YY_RULE_SETUP
          return ('!');
          YY_BREAK
        case 84:
          YY_RULE_SETUP
          return (OP_LOGIC_NEQ);
          YY_BREAK
        case 85:
          YY_RULE_SETUP
          return ('^');
          YY_BREAK
        case 86:
          YY_RULE_SETUP
          return (OP_XOR_EQ);
          YY_BREAK
        case 87:
          YY_RULE_SETUP
          return ('&');
          YY_BREAK
        case 88:
          YY_RULE_SETUP
          return ('|');
          YY_BREAK
        case 89:
          YY_RULE_SETUP
          return ('~');
          YY_BREAK
        case 90:
          /* rule 90 can match eol */
          YY_RULE_SETUP
          {
            size_t i = 1;
            size_t j;
            while (yytext[i] == ' ' || yytext[i] == '\t' || yytext[i] == '\r' || yytext[i] == '\n')
            {
              i++;
            }
            j = i;
            while (yytext[j] != '&')
            {
              j++;
            }
            yylval.str = vtkstrndup(&yytext[i], j - i);
            return (LA);
          }
          YY_BREAK
        case 91:
          /* rule 91 can match eol */
          YY_RULE_SETUP
          {
            size_t i = 1;
            size_t j;
            while (yytext[i] == ' ' || yytext[i] == '\t' || yytext[i] == '\r' || yytext[i] == '\n')
            {
              i++;
            }
            j = i;
            while (yytext[j] != '*')
            {
              j++;
            }
            yylval.str = vtkstrndup(&yytext[i], j - i);
            return (LP);
          }
          YY_BREAK
        case 92:
          /* rule 92 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 93:
          /* rule 93 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 94:
          /* rule 94 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 95:
          YY_RULE_SETUP
          return ('*');
          YY_BREAK
        case 96:
          YY_RULE_SETUP
          /* misc unused win32 macros */
          YY_BREAK
        case 97:
          /* rule 97 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (OSTREAM);
          }
          YY_BREAK
        case 98:
          /* rule 98 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (ISTREAM);
          }
          YY_BREAK
        case 99:
          /* rule 99 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (StdString);
          }
          YY_BREAK
        case 100:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (StdString);
          }
          YY_BREAK
        case 101:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (QT_ID);
          }
          YY_BREAK
        case 102:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C++11 */
          YY_BREAK
        case 103:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C++11 */
          YY_BREAK
        case 104:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C11 */
          YY_BREAK
        case 105:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C11 */
          YY_BREAK
        case 106:
          YY_RULE_SETUP
          return (THREAD_LOCAL); /* C11 */
          YY_BREAK
        case 107:
          YY_RULE_SETUP
          /* C11 */
          YY_BREAK
        case 108:
          YY_RULE_SETUP
          /* C11 */
          YY_BREAK
        case 109:
          YY_RULE_SETUP
          skip_macro_arguments(); /* C99 */
          YY_BREAK
        case 110:
          YY_RULE_SETUP
          skip_macro_arguments(); /* MSVC */
          YY_BREAK
        case 111:
          YY_RULE_SETUP
          skip_macro_arguments(); /* gcc attributes */
          YY_BREAK
        case 112:
          YY_RULE_SETUP
          skip_macro_arguments(); /* Windows linkage */
          YY_BREAK
        case 113:
          YY_RULE_SETUP
          /* Windows */
          YY_BREAK
        case 114:
          YY_RULE_SETUP
          /* gcc/clang/other extension */
          YY_BREAK
        case 115:
          YY_RULE_SETUP
          /* MSVC extension */
          YY_BREAK
        case 116:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (NULLPTR);
          }
          YY_BREAK
        case 117:
          YY_RULE_SETUP
          {
            const char* name = vtkstrndup(yytext, yyleng);
            MacroInfo* macro = vtkParsePreprocess_GetMacro(preprocessor, name);
            int expanded = 0;
            if (macro)
            {
              char* args = NULL;
              const char* emacro = NULL;

              if (macro->IsFunction)
              {
                args = get_macro_arguments();
                if (args)
                {
                  emacro = vtkParsePreprocess_ExpandMacro(preprocessor, macro, args);
                  if (!emacro)
                  {
                    print_preprocessor_error(VTK_PARSE_MACRO_NUMARGS, NULL, 0);
                    exit(1);
                  }
                  free(args);
                }
              }
              else if (macro->Definition && macro->Definition[0])
              {
                /* first see if macro evaluates to a constant value */
                preproc_int_t val;
                int is_unsigned;
                int r;
                macro->IsExcluded = 1;
                r = vtkParsePreprocess_EvaluateExpression(
                  preprocessor, macro->Definition, &val, &is_unsigned);
                macro->IsExcluded = 0;
                /* if it isn't a constant expression, then expand it */
                if (r >= VTK_PARSE_MACRO_UNDEFINED)
                {
                  emacro = vtkParsePreprocess_ExpandMacro(preprocessor, macro, NULL);
                  if (!emacro)
                  {
                    print_preprocessor_error(r, NULL, 0);
                    exit(1);
                  }
                }
              }
              else
              {
                /* macros with no definition expand to nothing */
                expanded = 1;
              }
              if (emacro)
              {
                /* invoke the parser on any expanded macros */
                push_macro(macro);
                push_buffer();
                yy_switch_to_buffer(yy_scan_string(emacro));
                vtkParsePreprocess_FreeMacroExpansion(preprocessor, macro, emacro);
                expanded = 1;
              }
            }
            if (!expanded)
            {
              /* if no macro expansion occurred, return the ID */
              yylval.str = name;
              if (yyleng > 3 && name[0] == 'v' && name[1] == 't' && name[2] == 'k')
              {
                return (VTK_ID);
              }
              else if (name[0] == 'Q')
              {
                return (QT_ID);
              }
              else
              {
                return (ID);
              }
            }
          }
          YY_BREAK
        case 118:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 119:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 120:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 121:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 122:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (HEX_LITERAL);
          }
          YY_BREAK
        case 123:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (BIN_LITERAL);
          }
          YY_BREAK
        case 124:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (OCT_LITERAL);
          }
          YY_BREAK
        case 125:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (INT_LITERAL);
          }
          YY_BREAK
        case 126:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (ZERO);
          }
          YY_BREAK
        case 127:
          /* rule 127 can match eol */
          YY_RULE_SETUP
          /* escaped newlines */
          YY_BREAK
        case 128:
          YY_RULE_SETUP
          /* whitespace */
          YY_BREAK
        case 129:
          /* rule 129 can match eol */
          YY_RULE_SETUP
          /* whitespace */
          YY_BREAK
        case 130:
          /* rule 130 can match eol */
          YY_RULE_SETUP
          return (BEGIN_ATTRIB);
          YY_BREAK
        case 131:
          YY_RULE_SETUP
          return ('{');
          YY_BREAK
        case 132:
          YY_RULE_SETUP
          return ('}');
          YY_BREAK
        case 133:
          YY_RULE_SETUP
          return ('[');
          YY_BREAK
        case 134:
          YY_RULE_SETUP
          return (']');
          YY_BREAK
        case 135:
          YY_RULE_SETUP
          return ('#');
          YY_BREAK
        case 136:
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          (yy_c_buf_p) = yy_cp = yy_bp + 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (OP_RSHIFT_A);
          YY_BREAK
        case 137:
          YY_RULE_SETUP
          return (OP_LSHIFT_EQ);
          YY_BREAK
        case 138:
          YY_RULE_SETUP
          return (OP_RSHIFT_EQ);
          YY_BREAK
        case 139:
          YY_RULE_SETUP
          return (OP_LSHIFT);
          YY_BREAK
        case 140:
          YY_RULE_SETUP
          return (OP_DOT_POINTER);
          YY_BREAK
        case 141:
          YY_RULE_SETUP
          return (OP_ARROW_POINTER);
          YY_BREAK
        case 142:
          YY_RULE_SETUP
          return (OP_ARROW);
          YY_BREAK
        case 143:
          YY_RULE_SETUP
          return (OP_INCR);
          YY_BREAK
        case 144:
          YY_RULE_SETUP
          return (OP_DECR);
          YY_BREAK
        case 145:
          YY_RULE_SETUP
          return (OP_PLUS_EQ);
          YY_BREAK
        case 146:
          YY_RULE_SETUP
          return (OP_MINUS_EQ);
          YY_BREAK
        case 147:
          YY_RULE_SETUP
          return (OP_TIMES_EQ);
          YY_BREAK
        case 148:
          YY_RULE_SETUP
          return (OP_DIVIDE_EQ);
          YY_BREAK
        case 149:
          YY_RULE_SETUP
          return (OP_REMAINDER_EQ);
          YY_BREAK
        case 150:
          YY_RULE_SETUP
          return (OP_AND_EQ);
          YY_BREAK
        case 151:
          YY_RULE_SETUP
          return (OP_OR_EQ);
          YY_BREAK
        case 152:
          YY_RULE_SETUP
          return (OP_XOR_EQ);
          YY_BREAK
        case 153:
          YY_RULE_SETUP
          return (OP_LOGIC_AND);
          YY_BREAK
        case 154:
          YY_RULE_SETUP
          return (OP_LOGIC_OR);
          YY_BREAK
        case 155:
          YY_RULE_SETUP
          return (OP_LOGIC_EQ);
          YY_BREAK
        case 156:
          YY_RULE_SETUP
          return (OP_LOGIC_NEQ);
          YY_BREAK
        case 157:
          YY_RULE_SETUP
          return (OP_LOGIC_LEQ);
          YY_BREAK
        case 158:
          YY_RULE_SETUP
          return (OP_LOGIC_GEQ);
          YY_BREAK
        case 159:
          YY_RULE_SETUP
          return (ELLIPSIS);
          YY_BREAK
        case 160:
          YY_RULE_SETUP
          return (DOUBLE_COLON);
          YY_BREAK
        case 161:
          YY_RULE_SETUP
          return ('[');
          YY_BREAK
        case 162:
          YY_RULE_SETUP
          return (']');
          YY_BREAK
        case 163:
          YY_RULE_SETUP
          return (yytext[0]);
          YY_BREAK
        case YY_STATE_EOF(INITIAL):
        {
          if (!pop_buffer())
          {
            yyterminate();
          }
        }
          YY_BREAK
        case 164:
          YY_RULE_SETUP
          {
            return (OTHER);
          }
          YY_BREAK
        case 165:
          YY_RULE_SETUP
          YY_FATAL_ERROR("flex scanner jammed");
          YY_BREAK

        case YY_END_OF_BUFFER:
        {
          /* Amount of text matched not including the EOB char. */
          int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;

          /* Undo the effects of YY_DO_BEFORE_ACTION. */
          *yy_cp = (yy_hold_char);
          YY_RESTORE_YY_MORE_OFFSET

          if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW)
          {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between YY_CURRENT_BUFFER and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
            YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
          }

          /* Note that here we test for yy_c_buf_p "<=" to the position
           * of the first EOB in the buffer, since yy_c_buf_p will
           * already have been incremented past the NUL character
           * (since all states make transitions on EOB to the
           * end-of-buffer state).  Contrast this with the test
           * in input().
           */
          if ((yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
          { /* This was really a NUL. */
            yy_state_type yy_next_state;

            (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans(yy_current_state);

            yy_bp = (yytext_ptr) + YY_MORE_ADJ;

            if (yy_next_state)
            {
              /* Consume the NUL. */
              yy_cp = ++(yy_c_buf_p);
              yy_current_state = yy_next_state;
              goto yy_match;
            }

            else
            {
              yy_cp = (yy_c_buf_p);
              goto yy_find_action;
            }
          }

          else
            switch (yy_get_next_buffer())
            {
              case EOB_ACT_END_OF_FILE:
              {
                (yy_did_buffer_switch_on_eof) = 0;

                if (yywrap())
                {
                  /* Note: because we've taken care in
                   * yy_get_next_buffer() to have set up
                   * yytext, we can now set up
                   * yy_c_buf_p so that if some total
                   * hoser (like flex itself) wants to
                   * call the scanner after we return the
                   * YY_NULL, it'll still work - another
                   * YY_NULL will get returned.
                   */
                  (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                  yy_act = YY_STATE_EOF(YY_START);
                  goto do_action;
                }

                else
                {
                  if (!(yy_did_buffer_switch_on_eof))
                    YY_NEW_FILE;
                }
                break;
              }

              case EOB_ACT_CONTINUE_SCAN:
                (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_match;

              case EOB_ACT_LAST_MATCH:
                (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_find_action;
            }
          break;
        }

        default:
          YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
      } /* end of action switch */
    }   /* end of scanning one token */
  }     /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer(void)
{
  char* dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char* source = (yytext_ptr);
  int number_to_move, i;
  int ret_val;

  if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
    YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

  if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0)
  { /* Don't try to fill the buffer, so this is an EOF. */
    if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1)
    {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
    }

    else
    {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
    }
  }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)-1);

  for (i = 0; i < number_to_move; ++i)
    *(dest++) = *(source++);

  if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

  else
  {
    int num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while (num_to_read <= 0)
    { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

      int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

      if (b->yy_is_our_buffer)
      {
        int new_size = b->yy_buf_size * 2;

        if (new_size <= 0)
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char*)
          /* Include room in for 2 EOB chars. */
          yyrealloc((void*)b->yy_ch_buf, (yy_size_t)(b->yy_buf_size + 2));
      }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = NULL;

      if (!b->yy_ch_buf)
        YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

      (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

      num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
    }

    if (num_to_read > YY_READ_BUF_SIZE)
      num_to_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), (yy_n_chars), num_to_read);

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  if ((yy_n_chars) == 0)
  {
    if (number_to_move == YY_MORE_ADJ)
    {
      ret_val = EOB_ACT_END_OF_FILE;
      yyrestart(yyin);
    }

    else
    {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
    }
  }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size)
  {
    /* Extend the array by 50%, plus the number we really need. */
    int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
      (char*)yyrealloc((void*)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t)new_size);
    if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
    /* "- 2" to take care of EOB's */
    YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
  }

  (yy_n_chars) += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

  (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state(void)
{
  yy_state_type yy_current_state;
  char* yy_cp;

  yy_current_state = (yy_start);
  yy_current_state += YY_AT_BOL();

  for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp)
  {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if (yy_accept[yy_current_state])
    {
      (yy_last_accepting_state) = yy_current_state;
      (yy_last_accepting_cpos) = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
    {
      yy_current_state = (int)yy_def[yy_current_state];
      if (yy_current_state >= 961)
        yy_c = yy_meta[yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state)
{
  int yy_is_jam;
  char* yy_cp = (yy_c_buf_p);

  YY_CHAR yy_c = 1;
  if (yy_accept[yy_current_state])
  {
    (yy_last_accepting_state) = yy_current_state;
    (yy_last_accepting_cpos) = yy_cp;
  }
  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
  {
    yy_current_state = (int)yy_def[yy_current_state];
    if (yy_current_state >= 961)
      yy_c = yy_meta[yy_c];
  }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  yy_is_jam = (yy_current_state == 960);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

static void yyunput(int c, char* yy_bp)
{
  char* yy_cp;

  yy_cp = (yy_c_buf_p);

  /* undo effects of setting up yytext */
  *yy_cp = (yy_hold_char);

  if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
  { /* need to shift things up to make room */
    /* +2 for EOB chars. */
    int number_to_move = (yy_n_chars) + 2;
    char* dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
    char* source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

    while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      *--dest = *--source;

    yy_cp += (int)(dest - source);
    yy_bp += (int)(dest - source);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) =
      (int)YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

    if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
      YY_FATAL_ERROR("flex scanner push-back overflow");
  }

  *--yy_cp = (char)c;

  if (c == '\n')
  {
    --yylineno;
  }

  (yytext_ptr) = yy_bp;
  (yy_hold_char) = *yy_cp;
  (yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void)
#else
static int input(void)
#endif

{
  int c;

  *(yy_c_buf_p) = (yy_hold_char);

  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR)
  {
    /* yy_c_buf_p now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
      /* This was really a NUL. */
      *(yy_c_buf_p) = '\0';

    else
    { /* need more input */
      int offset = (int)((yy_c_buf_p) - (yytext_ptr));
      ++(yy_c_buf_p);

      switch (yy_get_next_buffer())
      {
        case EOB_ACT_LAST_MATCH:
          /* This happens because yy_g_n_b()
           * sees that we've accumulated a
           * token and flags that we need to
           * try matching the token before
           * proceeding.  But for input(),
           * there's no matching to consider.
           * So convert the EOB_ACT_LAST_MATCH
           * to EOB_ACT_END_OF_FILE.
           */

          /* Reset buffer status. */
          yyrestart(yyin);

          /*FALLTHROUGH*/

        case EOB_ACT_END_OF_FILE:
        {
          if (yywrap())
            return 0;

          if (!(yy_did_buffer_switch_on_eof))
            YY_NEW_FILE;
#ifdef __cplusplus
          return yyinput();
#else
          return input();
#endif
        }

        case EOB_ACT_CONTINUE_SCAN:
          (yy_c_buf_p) = (yytext_ptr) + offset;
          break;
      }
    }
  }

  c = *(unsigned char*)(yy_c_buf_p); /* cast for 8-bit char's */
  *(yy_c_buf_p) = '\0';              /* preserve yytext */
  (yy_hold_char) = *++(yy_c_buf_p);

  YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
  if (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

    yylineno++;
  ;

  return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE* input_file)
{

  if (!YY_CURRENT_BUFFER)
  {
    yyensure_buffer_stack();
    YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
  }

  yy_init_buffer(YY_CURRENT_BUFFER, input_file);
  yy_load_buffer_state();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
{

  /* TODO. We should be able to replace this entire function body
   * with
   *    yypop_buffer_state();
   *    yypush_buffer_state(new_buffer);
   */
  yyensure_buffer_stack();
  if (YY_CURRENT_BUFFER == new_buffer)
    return;

  if (YY_CURRENT_BUFFER)
  {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  YY_CURRENT_BUFFER_LVALUE = new_buffer;
  yy_load_buffer_state();

  /* We don't actually know whether we did this switch during
   * EOF (yywrap()) processing, but the only time this flag
   * is looked at is after yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
  (yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state(void)
{
  (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
  (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
  yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
  (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char*)yyalloc((yy_size_t)(b->yy_buf_size + 2));
  if (!b->yy_ch_buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_is_our_buffer = 1;

  yy_init_buffer(b, file);

  return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
void yy_delete_buffer(YY_BUFFER_STATE b)
{

  if (!b)
    return;

  if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

  if (b->yy_is_our_buffer)
    yyfree((void*)b->yy_ch_buf);

  yyfree((void*)b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file)

{
  int oerrno = errno;

  yy_flush_buffer(b);

  b->yy_input_file = file;
  b->yy_fill_buffer = 1;

  /* If b is the current buffer, then yy_init_buffer was _probably_
   * called from yyrestart() or through yy_get_next_buffer.
   * In that case, we don't want to reset the lineno or column.
   */
  if (b != YY_CURRENT_BUFFER)
  {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  b->yy_is_interactive = file ? (isatty(fileno(file)) > 0) : 0;

  errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
void yy_flush_buffer(YY_BUFFER_STATE b)
{
  if (!b)
    return;

  b->yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[0];

  b->yy_at_bol = 1;
  b->yy_buffer_status = YY_BUFFER_NEW;

  if (b == YY_CURRENT_BUFFER)
    yy_load_buffer_state();
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void yypush_buffer_state(YY_BUFFER_STATE new_buffer)
{
  if (new_buffer == NULL)
    return;

  yyensure_buffer_stack();

  /* This block is copied from yy_switch_to_buffer. */
  if (YY_CURRENT_BUFFER)
  {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  /* Only push if top exists. Otherwise, replace top. */
  if (YY_CURRENT_BUFFER)
    (yy_buffer_stack_top)++;
  YY_CURRENT_BUFFER_LVALUE = new_buffer;

  /* copied from yy_switch_to_buffer. */
  yy_load_buffer_state();
  (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void yypop_buffer_state(void)
{
  if (!YY_CURRENT_BUFFER)
    return;

  yy_delete_buffer(YY_CURRENT_BUFFER);
  YY_CURRENT_BUFFER_LVALUE = NULL;
  if ((yy_buffer_stack_top) > 0)
    --(yy_buffer_stack_top);

  if (YY_CURRENT_BUFFER)
  {
    yy_load_buffer_state();
    (yy_did_buffer_switch_on_eof) = 1;
  }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack(void)
{
  yy_size_t num_to_alloc;

  if (!(yy_buffer_stack))
  {

    /* First allocation is just for 2 elements, since we don't know if this
     * scanner will even need a stack. We use 2 instead of 1 to avoid an
     * immediate realloc on the next call.
     */
    num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
    (yy_buffer_stack) =
      (struct yy_buffer_state**)yyalloc(num_to_alloc * sizeof(struct yy_buffer_state*));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

    (yy_buffer_stack_max) = num_to_alloc;
    (yy_buffer_stack_top) = 0;
    return;
  }

  if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1)
  {

    /* Increase the buffer to prepare for a possible push. */
    yy_size_t grow_size = 8 /* arbitrary grow size */;

    num_to_alloc = (yy_buffer_stack_max) + grow_size;
    (yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc(
      (yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state*));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    /* zero only the new slots.*/
    memset(
      (yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
    (yy_buffer_stack_max) = num_to_alloc;
  }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size)
{
  YY_BUFFER_STATE b;

  if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR ||
    base[size - 1] != YY_END_OF_BUFFER_CHAR)
    /* They forgot to leave room for the EOB's. */
    return NULL;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

  b->yy_buf_size = (int)(size - 2); /* "- 2" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = NULL;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  yy_switch_to_buffer(b);

  return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string(const char* yystr)
{

  return yy_scan_bytes(yystr, (int)strlen(yystr));
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes(const char* yybytes, int _yybytes_len)
{
  YY_BUFFER_STATE b;
  char* buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = (yy_size_t)(_yybytes_len + 2);
  buf = (char*)yyalloc(n);
  if (!buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

  for (i = 0; i < _yybytes_len; ++i)
    buf[i] = yybytes[i];

  buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

  b = yy_scan_buffer(buf, n);
  if (!b)
    YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error(const char* msg)
{
  fprintf(stderr, "%s\n", msg);
  exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                                                  \
  do                                                                                               \
  {                                                                                                \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    yytext[yyleng] = (yy_hold_char);                                                               \
    (yy_c_buf_p) = yytext + yyless_macro_arg;                                                      \
    (yy_hold_char) = *(yy_c_buf_p);                                                                \
    *(yy_c_buf_p) = '\0';                                                                          \
    yyleng = yyless_macro_arg;                                                                     \
  } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int yyget_lineno(void)
{

  return yylineno;
}

/** Get the input stream.
 *
 */
FILE* yyget_in(void)
{
  return yyin;
}

/** Get the output stream.
 *
 */
FILE* yyget_out(void)
{
  return yyout;
}

/** Get the length of the current token.
 *
 */
int yyget_leng(void)
{
  return yyleng;
}

/** Get the current token.
 *
 */

char* yyget_text(void)
{
  return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 *
 */
void yyset_lineno(int _line_number)
{

  yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE* _in_str)
{
  yyin = _in_str;
}

void yyset_out(FILE* _out_str)
{
  yyout = _out_str;
}

int yyget_debug(void)
{
  return yy_flex_debug;
}

void yyset_debug(int _bdebug)
{
  yy_flex_debug = _bdebug;
}

static int yy_init_globals(void)
{
  /* Initialization is the same as for the non-reentrant scanner.
   * This function is called from yylex_destroy(), so don't allocate here.
   */

  /* We do not touch yylineno unless the option is enabled. */
  yylineno = 1;

  (yy_buffer_stack) = NULL;
  (yy_buffer_stack_top) = 0;
  (yy_buffer_stack_max) = 0;
  (yy_c_buf_p) = NULL;
  (yy_init) = 0;
  (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
  yyin = stdin;
  yyout = stdout;
#else
  yyin = NULL;
  yyout = NULL;
#endif

  /* For future reference: Set errno on error, since we are called by
   * yylex_init()
   */
  return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(void)
{

  /* Pop the buffer stack, destroying each element. */
  while (YY_CURRENT_BUFFER)
  {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    yypop_buffer_state();
  }

  /* Destroy the stack itself. */
  yyfree((yy_buffer_stack));
  (yy_buffer_stack) = NULL;

  /* Reset the globals. This is important in a non-reentrant scanner so the next time
   * yylex() is called, initialization will occur. */
  yy_init_globals();

  return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char* s1, const char* s2, int n)
{

  int i;
  for (i = 0; i < n; ++i)
    s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char* s)
{
  int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void* yyalloc(yy_size_t size)
{
  return malloc(size);
}

void* yyrealloc(void* ptr, yy_size_t size)
{

  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
  return realloc(ptr, size);
}

void yyfree(void* ptr)
{
  free((char*)ptr); /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

/*
 * Return a parenthetical macro arg list as a new string.
 */
char* get_macro_arguments(void)
{
  char* cp = NULL;
  size_t i = 0;
  int depth;
  int ws = 0;
  int sl = 0;
  int c1 = input();

  if (c1 == '\0')
  {
    if (pop_buffer() == 0)
    {
      return NULL;
    }
  }

  while (c1 == ' ' || c1 == '\t' || c1 == '\r' || c1 == '\n')
  {
    c1 = input();
  }

  cp = (char*)malloc(4);

  if (c1 != '(')
  {
    unput(c1);
    free(cp);
    return NULL;
  }

  cp[i++] = '(';
  depth = 1;
  c1 = input();

  for (;;)
  {
    ws = 0;
    sl = 0;
    /* skip all whitespace */
    while (c1 == ' ' || c1 == '\t' || c1 == '\r' || c1 == '\n')
    {
      ws = 1;
      c1 = input();
    }
    if (c1 == '/')
    {
      c1 = input();
      if (c1 == '*')
      {
        /* skip a C style comment */
        ws = 1;
        if (skip_comment() == 0)
        {
          return NULL;
        }
        c1 = input();
      }
      else if (c1 == '/')
      {
        /* skip a C++ style comment */
        ws = 1;
        do
        {
          c1 = input();
        } while (c1 != '\n' && c1 != '\0');
        if (c1 == '\0')
        {
          return NULL;
        }
        c1 = input();
      }
      else
      {
        sl = 1;
      }
    }
    if (ws)
    {
      /* add a single space to replace any whitespace */
      cp[i++] = ' ';
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
    }
    if (sl)
    {
      /* add a single space to replace any whitespace */
      cp[i++] = '/';
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
    }
    if (c1 == '\"' || c1 == '\'')
    {
      int c2 = c1;
      int escaped = 2;
      int firstloop = 1;
      do
      {
        if (escaped)
        {
          --escaped;
        }
        if (!firstloop)
        {
          c1 = input();
        }
        firstloop = 0;
        if (c1 == '\0')
        {
          break;
        }
        if (escaped == 0 && c1 == '\\')
        {
          escaped = 2;
        }
        cp[i++] = (char)c1;
        if (i >= 4 && (i & (i - 1)) == 0)
        {
          char* oldcp = cp;
          cp = (char*)realloc(cp, 2 * i);
          if (!cp)
          {
            free(oldcp);
            return NULL;
          }
        }
      } while (c1 != c2 || escaped);
    }
    else if (c1 != '\0')
    {
      cp[i++] = (char)c1;
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
      cp[i] = '\0';
      if (c1 == '(')
      {
        depth++;
      }
      if (c1 == ')')
      {
        if (--depth == 0)
        {
          break;
        }
      }
    }
    else
    {
      return NULL;
    }
    c1 = input();
  }

  return cp;
}

void skip_macro_arguments(void)
{
  char* p = get_macro_arguments();
  free(p);
}

/*
 * Skip a C-style comment, return 0 if unterminated.
 */
int skip_comment(void)
{
  int savelineno = yylineno;
  int c1 = 0, c2 = input();
  for (;;)
  {
    if (c2 == 0 || c2 == EOF)
    {
      yylineno = savelineno;
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Cannot find end of comment.", 27);
      exit(1);
    }
    if (c1 == '*' && c2 == '/')
      break;
    c1 = c2;
    c2 = input();
  }
  return 1;
}

/*
 * If token contains a comment, make sure whole comment is skipped.
 */
int skip_trailing_comment(const char* text, size_t l)
{
  const char* cp = text;
  const char* ep = text + l;
  int incomment = 0;

  while (cp < ep)
  {
    while (cp < ep && *cp != '/' && *cp != '\"')
    {
      cp++;
    }
    if (cp >= ep)
    {
      break;
    }
    else if (cp[0] == '/' && cp[1] == '*')
    {
      incomment = 1;
      cp += 2;
      while (cp < ep && *cp != '*')
      {
        cp++;
      }
      if (cp[0] == '*' && cp[1] == '/')
      {
        incomment = 0;
        cp += 2;
      }
      else
      {
        cp++;
      }
    }
    else if (cp[0] == '\"')
    {
      cp++;
      while (cp < ep)
      {
        while (cp < ep && *cp != '\\' && *cp != '\"')
        {
          cp++;
        }
        if (cp >= ep)
        {
          break;
        }
        else if (*cp == '\"')
        {
          cp++;
          break;
        }
        else /* if (*cp == '\\') */
        {
          cp += 2;
        }
      }
    }
    else
    {
      cp++;
    }
  }

  if (incomment)
  {
    return skip_comment();
  }

  return 1;
}

/*
 * Skip ahead until the next preprocessor directive.
 * This will eat the '#' that starts the directive.
 * Return 0 if none found.
 */
int skip_to_next_directive(void)
{
  /* state == 0 at the start of a line */
  int state = 0;
  int c;

  c = input();

  while (c != 0 && c != EOF)
  {
    /* whitespace */
    if (c == ' ' || c == '\t')
    {
      c = input();
    }
    /* newline renews the start-of-line state */
    else if (c == '\n')
    {
      state = 0;
      c = input();
    }
    /* skip comments */
    else if (c == '/')
    {
      state = 1;
      if ((c = input()) == '*')
      {
        if (skip_comment() == 0)
        {
          return 0;
        }
        c = input();
      }
    }
    /* skip escaped characters */
    else if (c == '\\')
    {
      state = 1;
      if ((c = input()) == '\r')
      {
        if ((c = input()) == '\n')
        {
          c = input();
        }
      }
      else if (c != 0 && c != EOF)
      {
        c = input();
      }
    }
    /* any other chars except '#' at start of line */
    else if (c != '#' || state != 0)
    {
      state = 1;
      c = input();
    }
    else
    {
      break;
    }
  }

  return c;
}

/*
 * Skip to the next #else or #elif or #endif
 */
int skip_conditional_block(void)
{
  static char* linebuf = NULL;
  static size_t linemaxlen = 80;
  size_t i;
  int c;
  int result;

  if (linebuf == 0)
  {
    linebuf = (char*)malloc(linemaxlen);
  }

  for (;;)
  {
    if (skip_to_next_directive() == 0)
    {
      return 0;
    }
    c = input();
    while (c == ' ' || c == '\t')
    {
      c = input();
    }
    if (c == 0 || c == EOF)
    {
      return 0;
    }

    /* eat the whole line */
    i = 0;
    linebuf[i++] = '#';
    while (c != 0 && c != EOF && c != '\n')
    {
      if (i >= linemaxlen - 5)
      {
        char* oldlinebuf = linebuf;
        linemaxlen += i + 5;
        linebuf = (char*)realloc(linebuf, linemaxlen);
        if (!linebuf)
        {
          free(oldlinebuf);
          return 0;
        }
      }
      linebuf[i++] = c;
      /* be sure to skip escaped newlines */
      if (c == '\\')
      {
        c = input();
        linebuf[i++] = c;
        if (c == '\r')
        {
          c = input();
          linebuf[i++] = c;
        }
      }
      c = input();
    }
    linebuf[i++] = c;

    result = vtkParsePreprocess_HandleDirective(preprocessor, linebuf);
    if (result != VTK_PARSE_SKIP && result != VTK_PARSE_OK)
    {
      print_preprocessor_error(result, linebuf, i);
    }
    else if (result != VTK_PARSE_SKIP)
    {
      break;
    }
  }

  return 1;
}

/*
 * Skip ahead until one of the strings is found,
 * then skip to the end of the line.
 */
int skip_ahead_multi(const char* strings[])
{
  char textbuf[SKIP_MATCH_MAXLEN + 1];
  int c = 0;
  size_t i;

  for (i = 0; i < (SKIP_MATCH_MAXLEN + 1); i++)
  {
    textbuf[i] = '\0';
  }

  for (;;)
  {
    for (i = 0; i < SKIP_MATCH_MAXLEN; i++)
    {
      textbuf[i] = textbuf[i + 1];
    }

    c = input();
    if (c == 0 || c == EOF)
    {
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, NULL, 0);
      return 0;
    }

    textbuf[SKIP_MATCH_MAXLEN - 1] = c;

    for (i = 0; strings[i]; i++)
    {
      if (strcmp(&textbuf[SKIP_MATCH_MAXLEN - strlen(strings[i])], strings[i]) == 0)
      {
        break;
      }
    }
    if (strings[i])
    {
      break;
    }
  }

  while (c != 0 && c != EOF && c != '\n')
  {
    c = input();
  }

  return 1;
}

/*
 * Skip ahead until the string is found.
 */
int skip_ahead_until(const char* text)
{
  const char* strings[2];
  strings[0] = text;
  strings[1] = NULL;

  return skip_ahead_multi(strings);
}

/*
 * Called for doxygen C-style comments
 */
void doxygen_comment(void)
{
  char linetext[256];
  int savelineno = yylineno;
  int asterisk, isfirstline = 1;
  int type = DoxygenComment;
  int l = 0, i = 0, base = yyleng;
  int c1 = 0, c2 = input();
  for (l = 0; l < yyleng; l++)
  {
    linetext[l] = yytext[l];
  }
  if (l > 0 && yytext[l - 1] == '<')
  {
    type = TrailingComment;
  }
  for (;;)
  {
    if (c2 == 0 || c2 == EOF)
    {
      yylineno = savelineno;
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Cannot find end of comment.", 27);
      exit(1);
    }
    if (l < 256)
    {
      linetext[l++] = (char)c2;
    }
    if (c2 == '\n' || (c1 == '*' && c2 == '/'))
    {
      if (l >= 2 && linetext[l - 2] == '*' && linetext[l - 1] == '/')
      {
        l -= 2;
      }
      while (l > 0 &&
        (linetext[l - 1] == '\n' || linetext[l - 1] == '\r' || linetext[l - 1] == '\t' ||
          linetext[l - 1] == ' '))
      {
        l--;
      }
      if (!isfirstline)
      {
        /* reduce the base indentation if chars occur before base */
        asterisk = 0;
        for (i = yyleng - 3; i < base && i < l; i++)
        {
          if (linetext[i] == '*' && asterisk == 0)
          {
            asterisk = 1;
          }
          else if (linetext[i] != ' ')
          {
            break;
          }
        }
        if (i > yyleng - 3 && i < l && linetext[i] != ' ' && linetext[i - 1] == ' ')
        {
          i--;
        }
        base = i;
      }
      if (l > base)
      {
        i = base;
        l -= base;
        addCommentLine(&linetext[i], l, type);
      }
      else if (c1 != '*' || c2 != '/')
      {
        addCommentLine("", 0, type);
      }
      if (isfirstline)
      {
        isfirstline = 0;
        base = 256;
      }
      l = 0;
      if (c1 == '*' && c2 == '/')
      {
        break;
      }
    }
    c1 = c2;
    c2 = input();
  }
}

/*
 * Called for //! and /// doxygen comments (handles just one line)
 */
void doxygen_cpp_comment(void)
{
  int type = DoxygenComment;
  int pos = 2;
  while (yytext[pos - 2] != '/' || yytext[pos - 1] != '/')
    pos++;
  while (pos < yyleng && yytext[pos - 1] == '/' && yytext[pos] == '/')
    pos++;
  if (pos < yyleng && yytext[pos] == '!')
    pos++;
  if (pos < yyleng && yytext[pos] == '<')
  {
    pos++;
    type = TrailingComment;
  }
  addCommentLine(&yytext[pos], yyleng - pos, type);
}

/*
 * Called for ///@{
 */
void doxygen_group_start(void)
{
  /* Set the "ingroup" marker */
  setCommentMemberGroup(1);
}

/*
 * Called for ///@}
 */
void doxygen_group_end(void)
{
  /* Clear the "ingroup" marker */
  setCommentMemberGroup(0);
}

/*
 * Called for // Description:
 */
void vtk_comment(void)
{
  setCommentState(NormalComment);
}

/*
 * Called for // .NAME
 */
void vtk_name_comment(void)
{
  int pos = 1;
  while (yytext[pos - 1] != 'M' || yytext[pos] != 'E')
  {
    pos++;
  }
  pos++;
  setCommentState(NameComment);
  addCommentLine(&yytext[pos], yyleng - pos, NormalComment);
}

/*
 * Called for // .SECTION
 */
void vtk_section_comment(void)
{
  int pos = 1;
  while (yytext[pos - 1] != 'O' || yytext[pos] != 'N')
  {
    pos++;
  }
  pos++;
  if (pos < yyleng && yytext[pos] == ' ')
  {
    pos++;
  }

  if (yyleng - pos >= 11 && strncmp(&yytext[pos], "Description", 11) == 0)
  {
    setCommentState(DescriptionComment);
  }
  else if (yyleng - pos >= 8 &&
    (strncmp(&yytext[pos], "See Also", 8) == 0 || strncmp(&yytext[pos], "see also", 8) == 0))
  {
    setCommentState(SeeAlsoComment);
  }
  else if (yyleng - pos >= 7 && strncmp(&yytext[pos], "Caveats", 7) == 0)
  {
    setCommentState(CaveatsComment);
  }
  else
  {
    cpp_comment_line();
  }
}

/*
 * Called for each line that has a C++ comment but no code, unless the
 * comment is recognized as beginning a VTK or doxygen comment.
 */
void cpp_comment_line(void)
{
  int pos = 2;
  while (yytext[pos - 2] != '/' || yytext[pos - 1] != '/')
    pos++;
  addCommentLine(&yytext[pos], yyleng - pos, NormalComment);
}

/*
 * Called whenever a blank line is encountered.
 */
void blank_line(void)
{
  commentBreak();
}

/*
 * Convert a raw string into a non-raw string.
 */
const char* raw_string(const char* begin, int* has_ud_suffix)
{
  int savelineno = yylineno;
  char* textbuf;
  int c = 0;
  const char* delim;
  const char* cp = begin;
  char* dp;
  char* result;
  size_t i, j, n;
  size_t m = 1024;

  result = (char*)malloc(m);
  dp = result;

  while (*cp != '\"')
  {
    *dp++ = *cp++;
  }
  --dp;
  *dp++ = *cp++;

  delim = cp;

  for (n = 0;; n++)
  {
    if (delim[n] == '(')
    {
      break;
    }
  }

  textbuf = (char*)malloc(n + 1);

  for (i = 0; i < n + 1; i++)
  {
    c = input();
    textbuf[i] = c;
  }

  while (c != EOF)
  {
    if (textbuf[0] == ')' && (n == 0 || strncmp(&textbuf[1], delim, n) == 0))
    {
      break;
    }

    j = dp - result;
    if (j > m - 8)
    {
      m += 1024;
      result = (char*)realloc(result, m);
      if (!result)
      {
        print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
        exit(1);
      }
      dp = result + j;
    }

    if ((*textbuf >= ' ' && *textbuf <= '~') || (*textbuf & 0x80) != 0)
    {
      *dp++ = *textbuf;
    }
    else
      switch (*textbuf)
      {
        case '\a':
          *dp++ = '\\';
          *dp++ = 'a';
          break;
        case '\b':
          *dp++ = '\\';
          *dp++ = 'b';
          break;
        case '\f':
          *dp++ = '\\';
          *dp++ = 'f';
          break;
        case '\n':
          *dp++ = '\\';
          *dp++ = 'n';
          break;
        case '\r':
          *dp++ = '\\';
          *dp++ = 'r';
          break;
        case '\t':
          *dp++ = '\\';
          *dp++ = 't';
          break;
        case '\v':
          *dp++ = '\\';
          *dp++ = 'v';
          break;
        case '\\':
          *dp++ = '\\';
          *dp++ = '\\';
          break;
        case '\'':
          *dp++ = '\\';
          *dp++ = '\'';
          break;
        case '\"':
          *dp++ = '\\';
          *dp++ = '\"';
          break;
        default:
          sprintf(dp, "\\%3.3o", *textbuf);
          dp += 4;
          break;
      }

    for (i = 0; i < n; i++)
    {
      textbuf[i] = textbuf[i + 1];
    }

    c = input();
    textbuf[n] = c;
  }

  if (c == EOF || '\"' != input())
  {
    yylineno = savelineno;
    print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Unterminated raw string.", 24);
    exit(1);
  }

  *dp++ = '\"';

  c = input();
  if (vtkParse_CharType(c, CPRE_ID))
  {
    *has_ud_suffix = 1;
    do
    {
      *dp++ = c;
      c = input();
    } while (vtkParse_CharType(c, CPRE_XID));
  }
  else
  {
    *has_ud_suffix = 0;
  }
  unput(c);

  *dp = '\0';
  cp = vtkstrdup(result);
  free(result);
  free(textbuf);

  return cp;
}

/*
 * buffer stack, used for macro expansion and include files
 */
static size_t buffer_stack_size = 0;
static YY_BUFFER_STATE* buffer_stack = NULL;

/*
 * push the current buffer onto the buffer stack.
 */
void push_buffer(void)
{
  size_t n = buffer_stack_size;
  if (buffer_stack == NULL)
  {
    buffer_stack = (YY_BUFFER_STATE*)malloc(4 * sizeof(YY_BUFFER_STATE));
  }
  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    buffer_stack = (YY_BUFFER_STATE*)realloc(buffer_stack, 2 * n * sizeof(YY_BUFFER_STATE));
    if (!buffer_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }
  buffer_stack[buffer_stack_size++] = YY_CURRENT_BUFFER;
}

/*
 * pop the buffer stack and restore the previous buffer
 */
int pop_buffer(void)
{
  if (in_macro())
  {
    pop_macro();
  }
  else
  {
    pop_include();
  }
  if (buffer_stack_size == 0)
  {
    return 0;
  }
  yy_delete_buffer(YY_CURRENT_BUFFER);
  yy_switch_to_buffer(buffer_stack[--buffer_stack_size]);
  if (buffer_stack_size == 0)
  {
    free(buffer_stack);
    buffer_stack = NULL;
  }
  return 1;
}

/*
 * include stack, to tell what include is being evaluated
 */
static size_t include_stack_size = 0;
static FileInfo** include_stack = NULL;
static int* lineno_stack = NULL;

/*
 * push the current include onto the include stack.
 */
void push_include(const char* filename)
{
  FileInfo* file_info = NULL;
  int same_file = 0;
  size_t n = include_stack_size;

  if (include_stack == NULL)
  {
    include_stack = (FileInfo**)malloc(4 * sizeof(FileInfo*));
    lineno_stack = (int*)malloc(4 * sizeof(int));
  }

  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    include_stack = (FileInfo**)realloc(include_stack, 2 * n * sizeof(FileInfo*));
    if (!include_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
    lineno_stack = (int*)realloc(lineno_stack, 2 * n * sizeof(int));
    if (!lineno_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }

  lineno_stack[include_stack_size] = yyget_lineno();
  yyset_lineno(0);
  include_stack[include_stack_size++] = data;

  /* if the file is including itself */
  if (filename == data->FileName ||
    (filename != 0 && data->FileName != 0 && strcmp(filename, data->FileName) == 0))
  {
    same_file = 1;
  }

  /* make a new fileinfo, but only if we are in the base namespace
   * and only if the only items added so far are constants */
  if (!same_file && currentNamespace == data->Contents &&
    data->Contents->NumberOfItems == data->Contents->NumberOfConstants)
  {
    file_info = (FileInfo*)malloc(sizeof(FileInfo));
    vtkParse_InitFile(file_info);
    file_info->FileName = vtkstrdup(filename);
    file_info->Contents = (NamespaceInfo*)malloc(sizeof(NamespaceInfo));
    vtkParse_InitNamespace(file_info->Contents);
    vtkParse_AddIncludeToFile(data, file_info);
    file_info->Strings = data->Strings;
    data = file_info;
    currentNamespace = file_info->Contents;
  }
}

/*
 * pop the include stack
 */
void pop_include(void)
{
  if (include_stack_size > 0)
  {
    --include_stack_size;
    fclose(yyin);
    yyset_lineno(lineno_stack[include_stack_size]);
    if (data != include_stack[include_stack_size])
    {
      data = include_stack[include_stack_size];
      currentNamespace = data->Contents;
    }
  }
}

/*
 * macro stack, to tell what macro is being evaluated
 */
static size_t macro_stack_size = 0;
static MacroInfo** macro_stack = NULL;

/*
 * push the current macro onto the macro stack.
 */
void push_macro(MacroInfo* macro)
{
  size_t n = macro_stack_size;
  if (macro_stack == NULL)
  {
    macro_stack = (MacroInfo**)malloc(4 * sizeof(MacroInfo*));
  }
  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    macro_stack = (MacroInfo**)realloc(macro_stack, 2 * n * sizeof(MacroInfo*));
    if (!macro_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }
  macro_stack[macro_stack_size++] = macro;
  if (macro)
  {
    macro->IsExcluded = 1;
    if (macro_stack_size == 1)
    {
      macroName = macro->Name;
      macroUsed = 0;
      macroEnded = 0;
    }
  }
}

/*
 * pop the macro stack
 */
void pop_macro(void)
{
  MacroInfo* macro;

  if (macro_stack_size > 0)
  {
    macro = macro_stack[--macro_stack_size];
    if (macro)
    {
      macro->IsExcluded = 0;
    }
    if (macro_stack_size == 0)
    {
      free(macro_stack);
      macro_stack = NULL;
    }
  }
  macroEnded = 1;
}

/*
 * are we currently processing a macro?
 */
int in_macro(void)
{
  return (macro_stack_size > 0);
}

/*
 * print a preprocessor error code with filename and line number.
 */
void print_preprocessor_error(int result, const char* cp, size_t n)
{
  const char* text = "";

  switch (result)
  {
    case VTK_PARSE_OK:
    case VTK_PARSE_SKIP:
      return;
    case VTK_PARSE_PREPROC_DOUBLE:
      text = "double in preprocessor conditional";
      break;
    case VTK_PARSE_PREPROC_FLOAT:
      text = "float in preprocessor conditional";
      break;
    case VTK_PARSE_PREPROC_STRING:
      text = "string in preprocessor conditional";
      break;
    case VTK_PARSE_MACRO_UNDEFINED:
      text = "undefined macro";
      break;
    case VTK_PARSE_MACRO_REDEFINED:
      text = "redefined macro";
      break;
    case VTK_PARSE_FILE_NOT_FOUND:
      text = "file not found";
      break;
    case VTK_PARSE_FILE_OPEN_ERROR:
      text = "can\'t open file";
      break;
    case VTK_PARSE_FILE_READ_ERROR:
      text = "input/output error";
      break;
    case VTK_PARSE_MACRO_NUMARGS:
      text = "wrong number of macro args";
      break;
    case VTK_PARSE_SYNTAX_ERROR:
      text = "syntax error";
      break;
    case VTK_PARSE_OUT_OF_MEMORY:
      text = "out of memory";
      break;
  }

  /* be silent about missing include files */
  if (result == VTK_PARSE_FILE_NOT_FOUND)
  {
    return;
  }

  print_parser_error(text, cp, n);
}

/*
 * print an error with filename and line number.
 */
void print_parser_error(const char* text, const char* cp, size_t n)
{
  size_t j = 0;
  const char* fn = "(none)";

  if (CommandName)
  {
    fprintf(yyout, "%s: ", CommandName);
  }

  if (data->FileName)
  {
    fn = data->FileName;
  }
  fprintf(yyout, "In %s:", fn);
  for (j = 0; j < include_stack_size; j++)
  {
    fprintf(yyout, "%i:\nIn %s:", lineno_stack[j], include_stack[j]->FileName);
  }
  fprintf(yyout, "%i:", yylineno);

  if (cp)
  {
    fprintf(yyout, " %s: %*.*s\n", text, (int)n, (int)n, cp);
  }
  else if (text)
  {
    fprintf(yyout, " %s.\n", text);
  }
  else
  {
    fprintf(yyout, "\n");
  }
}

/*
 * Execute a preprocessor directive.
 */
void preprocessor_directive(const char* text, size_t l)
{
  int result = 0;
  size_t n = 0;
  const char* cp = text;
  const char* ep = text + l;
  const char* directive = NULL;

  /* find the directive, store its length in "n" */
  while (*cp == ' ' || *cp == '\t')
  {
    cp++;
  }
  if (*cp == '#')
  {
    cp++;
  }
  while ((*cp == ' ' || *cp == '\t') && cp < ep)
  {
    cp++;
  }
  directive = cp;
  while (*cp >= 'a' && *cp <= 'z' && cp < ep)
  {
    cp++;
  }
  n = cp - directive;
  while ((*cp == ' ' || *cp == '\t') && cp < ep)
  {
    cp++;
  }

  if (n == 7 && strncmp(directive, "include", n) == 0)
  {
    /* include files */
    int already_loaded = 0;
    if (*cp == '<' || *cp == '\"')
    {
      /* if asked to recurse into header files */
      if (Recursive && ep - cp > 3)
      {
        const char* dp;
        dp = vtkParsePreprocess_FindIncludeFile(preprocessor, &cp[1],
          (*cp != '\"' ? VTK_PARSE_SYSTEM_INCLUDE : VTK_PARSE_SOURCE_INCLUDE), &already_loaded);
        if (dp)
        {
          yyin = vtkParse_FileOpen(dp, "r");
          if (yyin)
          {
            push_include(dp);
            push_buffer();
            yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
            return;
          }
        }
      }
    }
  }

  /* let the preprocessor handle the directive */
  result = vtkParsePreprocess_HandleDirective(preprocessor, text);

  if (result == VTK_PARSE_SKIP)
  {
    skip_conditional_block();
  }
  else if (result != VTK_PARSE_OK)
  {
    print_preprocessor_error(result, text, l);
    if ((result & VTK_PARSE_FATAL_ERROR) != 0)
    {
      exit(1);
    }
  }
  else if (n == 6 && strncmp(directive, "define", n) == 0)
  {
    closeComment();
    if (ep - cp > 4 && strncmp(cp, "VTK", 3) == 0)
    {
      /* macros that start with "VTK" */
      MacroInfo* macro;

      macro = vtkParsePreprocess_GetMacro(preprocessor, cp);
      if (macro && macro->Definition && !macro->IsFunction)
      {
        /* if macro evaluates to a constant, add it as a constant */
        macro->IsExcluded = 1;
        if (guess_constant_type(macro->Definition) == 0)
        {
          result = VTK_PARSE_MACRO_UNDEFINED;
        }
        macro->IsExcluded = 0;
        if (result < VTK_PARSE_MACRO_UNDEFINED)
        {
          add_constant(vtkstrdup(macro->Name), vtkstrdup(macro->Definition), 0, 0, NULL, 1);
        }
      }
    }
  }
}
